"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWludGVydmlldy1jaGF0Ly4vbm9kZV9tb2R1bGVzL2FpL25vZGVfbW9kdWxlcy9uYW5vaWQvbm9uLXNlY3VyZS9pbmRleC5qcz80M2M4Il0sInNvdXJjZXNDb250ZW50IjpbImxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xubGV0IGN1c3RvbUFscGhhYmV0ID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSA9IDIxKSA9PiB7XG4gIHJldHVybiAoc2l6ZSA9IGRlZmF1bHRTaXplKSA9PiB7XG4gICAgbGV0IGlkID0gJydcbiAgICBsZXQgaSA9IHNpemVcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZCArPSBhbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIGFscGhhYmV0Lmxlbmd0aCkgfCAwXVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxufVxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+IHtcbiAgbGV0IGlkID0gJydcbiAgbGV0IGkgPSBzaXplXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZCArPSB1cmxBbHBoYWJldFsoTWF0aC5yYW5kb20oKSAqIDY0KSB8IDBdXG4gIH1cbiAgcmV0dXJuIGlkXG59XG5leHBvcnQgeyBuYW5vaWQsIGN1c3RvbUFscGhhYmV0IH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* __next_internal_client_entry_do_not_use__ experimental_useAssistant,useChat,useCompletion auto */ // react/use-chat.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>{\n            tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\";\n        })) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// shared/utils.ts\n\nvar nanoid = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_2__.customAlphabet)(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", 7);\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n// shared/parse-complex-response.ts\nasync function parseComplexResponse({ reader, abortControllerRef, update, onFinish, generateId = nanoid, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    const createdAt = getCurrentDate();\n    const prefixMap = {\n        data: []\n    };\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            prefixMap[\"data\"].push(...value);\n        }\n        const responseMessage = prefixMap[\"text\"];\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean);\n        update(merged, [\n            ...prefixMap[\"data\"]\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish(prefixMap);\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data: prefixMap.data\n    };\n}\n// shared/call-chat-api.ts\nasync function callChatApi({ api, messages, body, credentials, headers, abortController, appendMessage, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, generateId }) {\n    var _a;\n    const response = await fetch(api, {\n        method: \"POST\",\n        body: JSON.stringify({\n            messages,\n            ...body\n        }),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error(await response.text() || \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    const isComplexMode = response.headers.get(COMPLEX_HEADER) === \"true\";\n    if (isComplexMode) {\n        return await parseComplexResponse({\n            reader,\n            abortControllerRef: abortController != null ? {\n                current: abortController()\n            } : void 0,\n            update: onUpdate,\n            onFinish (prefixMap) {\n                if (onFinish && prefixMap.text != null) {\n                    onFinish(prefixMap.text);\n                }\n            },\n            generateId\n        });\n    } else {\n        const createdAt = /* @__PURE__ */ new Date();\n        const decode = createChunkDecoder(false);\n        let streamedResponse = \"\";\n        const replyId = generateId();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        while(true){\n            const { done, value } = await reader.read();\n            if (done) {\n                break;\n            }\n            streamedResponse += decode(value);\n            if (streamedResponse.startsWith('{\"function_call\":')) {\n                responseMessage[\"function_call\"] = streamedResponse;\n            } else if (streamedResponse.startsWith('{\"tool_calls\":')) {\n                responseMessage[\"tool_calls\"] = streamedResponse;\n            } else {\n                responseMessage[\"content\"] = streamedResponse;\n            }\n            appendMessage({\n                ...responseMessage\n            });\n            if ((abortController == null ? void 0 : abortController()) === null) {\n                reader.cancel();\n                break;\n            }\n        }\n        if (streamedResponse.startsWith('{\"function_call\":')) {\n            const parsedFunctionCall = JSON.parse(streamedResponse).function_call;\n            responseMessage[\"function_call\"] = parsedFunctionCall;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (streamedResponse.startsWith('{\"tool_calls\":')) {\n            const parsedToolCalls = JSON.parse(streamedResponse).tool_calls;\n            responseMessage[\"tool_calls\"] = parsedToolCalls;\n            appendMessage({\n                ...responseMessage\n            });\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n}\n// shared/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse: getStreamedResponse2, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse2();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// react/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields)=>{\n    var _a, _b;\n    const previousMessages = messagesRef.current;\n    mutate(chatRequest.messages, false);\n    const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(({ role, content, name, function_call, tool_calls, tool_call_id })=>({\n            role,\n            content,\n            tool_call_id,\n            ...name !== void 0 && {\n                name\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tool_calls !== void 0 && {\n                tool_calls\n            }\n        }));\n    if (typeof api !== \"string\") {\n        const replyId = generateId();\n        const createdAt = /* @__PURE__ */ new Date();\n        let responseMessage = {\n            id: replyId,\n            createdAt,\n            content: \"\",\n            role: \"assistant\"\n        };\n        async function readRow(promise) {\n            const { content, ui, next } = await promise;\n            responseMessage[\"content\"] = content;\n            responseMessage[\"ui\"] = await ui;\n            mutate([\n                ...chatRequest.messages,\n                {\n                    ...responseMessage\n                }\n            ], false);\n            if (next) {\n                await readRow(next);\n            }\n        }\n        try {\n            const promise = api({\n                messages: constructedMessagesPayload,\n                data: chatRequest.data\n            });\n            await readRow(promise);\n        } catch (e) {\n            mutate(previousMessages, false);\n            throw e;\n        }\n        if (onFinish) {\n            onFinish(responseMessage);\n        }\n        return responseMessage;\n    }\n    return await callChatApi({\n        api,\n        messages: constructedMessagesPayload,\n        body: {\n            data: chatRequest.data,\n            ...extraMetadataRef.current.body,\n            ...(_a = chatRequest.options) == null ? void 0 : _a.body,\n            ...chatRequest.functions !== void 0 && {\n                functions: chatRequest.functions\n            },\n            ...chatRequest.function_call !== void 0 && {\n                function_call: chatRequest.function_call\n            },\n            ...chatRequest.tools !== void 0 && {\n                tools: chatRequest.tools\n            },\n            ...chatRequest.tool_choice !== void 0 && {\n                tool_choice: chatRequest.tool_choice\n            }\n        },\n        credentials: extraMetadataRef.current.credentials,\n        headers: {\n            ...extraMetadataRef.current.headers,\n            ...(_b = chatRequest.options) == null ? void 0 : _b.headers\n        },\n        abortController: ()=>abortControllerRef.current,\n        appendMessage (message) {\n            mutate([\n                ...chatRequest.messages,\n                message\n            ], false);\n        },\n        restoreMessagesOnFailure () {\n            mutate(previousMessages, false);\n        },\n        onResponse,\n        onUpdate (merged, data) {\n            mutate([\n                ...chatRequest.messages,\n                ...merged\n            ], false);\n            mutateStreamData([\n                ...existingData || [],\n                ...data || []\n            ], false);\n        },\n        onFinish,\n        generateId\n    });\n};\nfunction useChat({ api = \"/api/chat\", id, initialMessages, initialInput = \"\", sendExtraMessageFields, experimental_onFunctionCall, experimental_onToolCall, onResponse, onFinish, onError, credentials, headers, body, generateId = nanoid } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const idKey = id != null ? id : hookId;\n    const chatKey = typeof api === \"string\" ? [\n        api,\n        idKey\n    ] : idKey;\n    const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"messages\"\n    ], null, {\n        fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"streamData\"\n    ], null);\n    const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        chatKey,\n        \"error\"\n    ], null);\n    const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        messagesRef.current = messages || [];\n    }, [\n        messages\n    ]);\n    const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (chatRequest)=>{\n        try {\n            mutateLoading(true);\n            setError(void 0);\n            const abortController = new AbortController();\n            abortControllerRef.current = abortController;\n            await processChatStream({\n                getStreamedResponse: ()=>getStreamedResponse(api, chatRequest, mutate, mutateStreamData, streamData, extraMetadataRef, messagesRef, abortControllerRef, generateId, onFinish, onResponse, sendExtraMessageFields),\n                experimental_onFunctionCall,\n                experimental_onToolCall,\n                updateChatRequest: (chatRequestParam)=>{\n                    chatRequest = chatRequestParam;\n                },\n                getCurrentMessages: ()=>messagesRef.current\n            });\n            abortControllerRef.current = null;\n        } catch (err) {\n            if (err.name === \"AbortError\") {\n                abortControllerRef.current = null;\n                return null;\n            }\n            if (onError && err instanceof Error) {\n                onError(err);\n            }\n            setError(err);\n        } finally{\n            mutateLoading(false);\n        }\n    }, [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        mutateStreamData,\n        streamData,\n        sendExtraMessageFields,\n        experimental_onFunctionCall,\n        experimental_onToolCall,\n        messagesRef,\n        abortControllerRef,\n        generateId\n    ]);\n    const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (message, { options, functions, function_call, tools, tool_choice, data } = {})=>{\n        if (!message.id) {\n            message.id = generateId();\n        }\n        const chatRequest = {\n            messages: messagesRef.current.concat(message),\n            options,\n            data,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest,\n        generateId\n    ]);\n    const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async ({ options, functions, function_call, tools, tool_choice } = {})=>{\n        if (messagesRef.current.length === 0) return null;\n        const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n        if (lastMessage.role === \"assistant\") {\n            const chatRequest2 = {\n                messages: messagesRef.current.slice(0, -1),\n                options,\n                ...functions !== void 0 && {\n                    functions\n                },\n                ...function_call !== void 0 && {\n                    function_call\n                },\n                ...tools !== void 0 && {\n                    tools\n                },\n                ...tool_choice !== void 0 && {\n                    tool_choice\n                }\n            };\n            return triggerRequest(chatRequest2);\n        }\n        const chatRequest = {\n            messages: messagesRef.current,\n            options,\n            ...functions !== void 0 && {\n                functions\n            },\n            ...function_call !== void 0 && {\n                function_call\n            },\n            ...tools !== void 0 && {\n                tools\n            },\n            ...tool_choice !== void 0 && {\n                tool_choice\n            }\n        };\n        return triggerRequest(chatRequest);\n    }, [\n        triggerRequest\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortControllerRef.current) {\n            abortControllerRef.current.abort();\n            abortControllerRef.current = null;\n        }\n    }, []);\n    const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messages2)=>{\n        mutate(messages2, false);\n        messagesRef.current = messages2;\n    }, [\n        mutate\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e, options = {}, metadata)=>{\n        if (metadata) {\n            extraMetadataRef.current = {\n                ...extraMetadataRef.current,\n                ...metadata\n            };\n        }\n        e.preventDefault();\n        if (!input) return;\n        append({\n            content: input,\n            role: \"user\",\n            createdAt: /* @__PURE__ */ new Date()\n        }, options);\n        setInput(\"\");\n    }, [\n        input,\n        append\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        messages: messages || [],\n        error,\n        append,\n        reload,\n        stop,\n        setMessages,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-completion.ts\n\n\n// shared/call-completion-api.ts\nasync function callCompletionApi({ api, prompt, credentials, headers, body, setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        const isComplexMode = res.headers.get(COMPLEX_HEADER) === \"true\";\n        if (isComplexMode) {\n            for await (const { type, value } of readDataStream(reader, {\n                isAborted: ()=>abortController === null\n            })){\n                switch(type){\n                    case \"text\":\n                        {\n                            result += value;\n                            setCompletion(result);\n                            break;\n                        }\n                    case \"data\":\n                        {\n                            onData == null ? void 0 : onData(value);\n                            break;\n                        }\n                }\n            }\n        } else {\n            const decoder = createChunkDecoder();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) {\n                    break;\n                }\n                result += decoder(value);\n                setCompletion(result);\n                if (abortController === null) {\n                    reader.cancel();\n                    break;\n                }\n            }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// react/use-completion.ts\nfunction useCompletion({ api = \"/api/completion\", id, initialCompletion = \"\", initialInput = \"\", credentials, headers, body, onResponse, onFinish, onError } = {}) {\n    const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n    const completionId = id || hookId;\n    const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        api,\n        completionId\n    ], null, {\n        fallbackData: initialCompletion\n    });\n    const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"loading\"\n    ], null);\n    const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"])([\n        completionId,\n        \"streamData\"\n    ], null);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const completion = data;\n    const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        credentials,\n        headers,\n        body\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        extraMetadataRef.current = {\n            credentials,\n            headers,\n            body\n        };\n    }, [\n        credentials,\n        headers,\n        body\n    ]);\n    const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>callCompletionApi({\n            api,\n            prompt,\n            credentials: extraMetadataRef.current.credentials,\n            headers: {\n                ...extraMetadataRef.current.headers,\n                ...options == null ? void 0 : options.headers\n            },\n            body: {\n                ...extraMetadataRef.current.body,\n                ...options == null ? void 0 : options.body\n            },\n            setCompletion: (completion2)=>mutate(completion2, false),\n            setLoading: mutateLoading,\n            setError,\n            setAbortController,\n            onResponse,\n            onFinish,\n            onError,\n            onData: (data2)=>{\n                mutateStreamData([\n                    ...streamData || [],\n                    ...data2 || []\n                ], false);\n            }\n        }), [\n        mutate,\n        mutateLoading,\n        api,\n        extraMetadataRef,\n        setAbortController,\n        onResponse,\n        onFinish,\n        onError,\n        setError,\n        streamData,\n        mutateStreamData\n    ]);\n    const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n        if (abortController) {\n            abortController.abort();\n            setAbortController(null);\n        }\n    }, [\n        abortController\n    ]);\n    const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((completion2)=>{\n        mutate(completion2, false);\n    }, [\n        mutate\n    ]);\n    const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (prompt, options)=>{\n        return triggerRequest(prompt, options);\n    }, [\n        triggerRequest\n    ]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n    const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e)=>{\n        e.preventDefault();\n        if (!input) return;\n        return complete(input);\n    }, [\n        input,\n        complete\n    ]);\n    const handleInputChange = (e)=>{\n        setInput(e.target.value);\n    };\n    return {\n        completion,\n        complete,\n        error,\n        setCompletion,\n        stop,\n        input,\n        setInput,\n        handleInputChange,\n        handleSubmit,\n        isLoading,\n        data: streamData\n    };\n}\n// react/use-assistant.ts\n\nfunction experimental_useAssistant({ api, threadId: threadIdParam, credentials, headers, body }) {\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n    const [threadId, setThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n    const handleInputChange = (event)=>{\n        setInput(event.target.value);\n    };\n    const submitMessage = async (event, requestOptions)=>{\n        var _a, _b;\n        (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n        if (input === \"\") {\n            return;\n        }\n        setStatus(\"in_progress\");\n        setMessages((messages2)=>[\n                ...messages2,\n                {\n                    id: \"\",\n                    role: \"user\",\n                    content: input\n                }\n            ]);\n        setInput(\"\");\n        const result = await fetch(api, {\n            method: \"POST\",\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            body: JSON.stringify({\n                ...body,\n                // always use user-provided threadId when available:\n                threadId: (_b = threadIdParam != null ? threadIdParam : threadId) != null ? _b : null,\n                message: input,\n                // optional request data:\n                data: requestOptions == null ? void 0 : requestOptions.data\n            })\n        });\n        if (result.body == null) {\n            throw new Error(\"The response body is empty.\");\n        }\n        try {\n            for await (const { type, value } of readDataStream(result.body.getReader())){\n                switch(type){\n                    case \"assistant_message\":\n                        {\n                            setMessages((messages2)=>[\n                                    ...messages2,\n                                    {\n                                        id: value.id,\n                                        role: value.role,\n                                        content: value.content[0].text.value\n                                    }\n                                ]);\n                            break;\n                        }\n                    case \"data_message\":\n                        {\n                            setMessages((messages2)=>{\n                                var _a2;\n                                return [\n                                    ...messages2,\n                                    {\n                                        id: (_a2 = value.id) != null ? _a2 : \"\",\n                                        role: \"data\",\n                                        content: \"\",\n                                        data: value.data\n                                    }\n                                ];\n                            });\n                            break;\n                        }\n                    case \"assistant_control_data\":\n                        {\n                            setThreadId(value.threadId);\n                            setMessages((messages2)=>{\n                                const lastMessage = messages2[messages2.length - 1];\n                                lastMessage.id = value.messageId;\n                                return [\n                                    ...messages2.slice(0, messages2.length - 1),\n                                    lastMessage\n                                ];\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            setError(value);\n                            break;\n                        }\n                }\n            }\n        } catch (error2) {\n            setError(error2);\n        }\n        setStatus(\"awaiting_message\");\n    };\n    return {\n        messages,\n        threadId,\n        input,\n        setInput,\n        handleInputChange,\n        submitMessage,\n        status,\n        error\n    };\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFnRTtBQUMzQjs7QUNjckMsSUFBTU0saUJBQWtEO0lBQ3REQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRRjtRQUFNO0lBQy9CO0FBQ0Y7QUFFQSxJQUFNRyx5QkFJRjtJQUNGTixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQ0VBLFNBQVMsUUFDVCxPQUFPQSxVQUFVLFlBQ2pCLENBQUUsb0JBQW1CQSxLQUFBLEtBQ3JCLE9BQU9BLE1BQU1JLGFBQUEsS0FBa0IsWUFDL0JKLE1BQU1JLGFBQUEsSUFBaUIsUUFDdkIsQ0FBRSxXQUFVSixNQUFNSSxhQUFBLEtBQ2xCLENBQUUsZ0JBQWVKLE1BQU1JLGFBQUEsS0FDdkIsT0FBT0osTUFBTUksYUFBQSxDQUFjTixJQUFBLEtBQVMsWUFDcEMsT0FBT0UsTUFBTUksYUFBQSxDQUFjQyxTQUFBLEtBQWMsVUFDekM7WUFDQSxNQUFNLElBQUlKLE1BQ1I7UUFFSjtRQUVBLE9BQU87WUFDTEMsTUFBTTtZQUNORjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLElBQU1NLGlCQUE0RDtJQUNoRVQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQ0M7UUFDTixJQUFJLENBQUNPLE1BQU1DLE9BQUEsQ0FBUVIsUUFBUTtZQUN6QixNQUFNLElBQUlDLE1BQU07UUFDbEI7UUFFQSxPQUFPO1lBQUVDLE1BQU07WUFBUUY7UUFBTTtJQUMvQjtBQUNGO0FBRUEsSUFBTVMsa0JBQW9EO0lBQ3hEWixNQUFNO0lBQ05DLE1BQU07SUFDTkMsT0FBTyxDQUFDQztRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSUMs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QUtoQixLQUFBO29DQUNqQztpQ0FDRDs0QkFDRDt3QkFDRjtvQkFFQSxLQUFLO3dCQUFnQjs0QkFDbkJrTCxZQUFZLENBQUExRjtnQ0F6S3hCLElBQUFXO2dDQXlLb0M7dUNBQ25CWDtvQ0FDSDt3Q0FDRTdFLElBQUEsQ0FBSXdGLE1BQUFuRyxNQUFNVyxFQUFBLEtBQU4sT0FBQXdGLE1BQVk7d0NBQ2hCdkYsTUFBTTt3Q0FDTkMsU0FBUzt3Q0FDVHFFLE1BQU1sRixNQUFNa0YsSUFBQTtvQ0FDZDtpQ0FDRjs0QkFBQTs0QkFDQTt3QkFDRjtvQkFFQSxLQUFLO3dCQUEwQjs0QkFDN0J1SCxZQUFZek0sTUFBTWtCLFFBQVE7NEJBRzFCZ0ssWUFBWSxDQUFBMUY7Z0NBQ1YsTUFBTXVGLGNBQWN2RixTQUFBQSxDQUFTQSxVQUFTcEMsTUFBQSxHQUFTLEVBQUM7Z0NBQ2hEMkgsWUFBWXBLLEVBQUEsR0FBS1gsTUFBTW1CLFNBQUE7Z0NBQ3ZCLE9BQU87dUNBQUlxRSxVQUFTbkQsS0FBQSxDQUFNLEdBQUdtRCxVQUFTcEMsTUFBQSxHQUFTO29DQUFJMkg7aUNBQVc7NEJBQ2hFOzRCQUVBO3dCQUNGO29CQUVBLEtBQUs7d0JBQVM7NEJBQ1pQLFNBQVN4Szs0QkFDVDt3QkFDRjtnQkFDRjtZQUNGO1FBQ0YsU0FBU3VLLFFBQVA7WUFDQUMsU0FBU0Q7UUFDWDtRQUVBb0MsVUFBVTtJQUNaO0lBRUEsT0FBTztRQUNMbkg7UUFDQXRFO1FBQ0FpSztRQUNBQztRQUNBSTtRQUNBcUI7UUFDQUg7UUFDQW5DO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2FpLWludGVydmlldy1jaGF0Ly4uL3VzZS1jaGF0LnRzPzg4MjgiLCJ3ZWJwYWNrOi8vYWktaW50ZXJ2aWV3LWNoYXQvLi4vLi4vc2hhcmVkL3N0cmVhbS1wYXJ0cy50cz9jNGE4Iiwid2VicGFjazovL2FpLWludGVydmlldy1jaGF0Ly4uLy4uL3NoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzPzE4ZjEiLCJ3ZWJwYWNrOi8vYWktaW50ZXJ2aWV3LWNoYXQvLi4vLi4vc2hhcmVkL3V0aWxzLnRzP2Y4Y2YiLCJ3ZWJwYWNrOi8vYWktaW50ZXJ2aWV3LWNoYXQvLi4vLi4vc2hhcmVkL3BhcnNlLWNvbXBsZXgtcmVzcG9uc2UudHM/NjVlMCIsIndlYnBhY2s6Ly9haS1pbnRlcnZpZXctY2hhdC8uLi8uLi9zaGFyZWQvY2FsbC1jaGF0LWFwaS50cz9iNTViIiwid2VicGFjazovL2FpLWludGVydmlldy1jaGF0Ly4uLy4uL3NoYXJlZC9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzPzhkN2YiLCJ3ZWJwYWNrOi8vYWktaW50ZXJ2aWV3LWNoYXQvLi4vdXNlLWNvbXBsZXRpb24udHM/YWU3ZiIsIndlYnBhY2s6Ly9haS1pbnRlcnZpZXctY2hhdC8uLi8uLi9zaGFyZWQvY2FsbC1jb21wbGV0aW9uLWFwaS50cz84NTI1Iiwid2VicGFjazovL2FpLWludGVydmlldy1jaGF0Ly4uL3VzZS1hc3Npc3RhbnQudHM/MjgxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IsIHsgS2V5ZWRNdXRhdG9yIH0gZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDaGF0QXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY2hhdC1hcGknO1xuaW1wb3J0IHsgcHJvY2Vzc0NoYXRTdHJlYW0gfSBmcm9tICcuLi9zaGFyZWQvcHJvY2Vzcy1jaGF0LXN0cmVhbSc7XG5pbXBvcnQgdHlwZSB7XG4gIENoYXRSZXF1ZXN0LFxuICBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gIENyZWF0ZU1lc3NhZ2UsXG4gIElkR2VuZXJhdG9yLFxuICBKU09OVmFsdWUsXG4gIE1lc3NhZ2UsXG4gIFVzZUNoYXRPcHRpb25zLFxufSBmcm9tICcuLi9zaGFyZWQvdHlwZXMnO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnLi4vc2hhcmVkL3V0aWxzJztcbmltcG9ydCB0eXBlIHtcbiAgUmVhY3RSZXNwb25zZVJvdyxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UsXG59IGZyb20gJy4uL3N0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlJztcbmV4cG9ydCB0eXBlIHsgQ3JlYXRlTWVzc2FnZSwgTWVzc2FnZSwgVXNlQ2hhdE9wdGlvbnMgfTtcblxuZXhwb3J0IHR5cGUgVXNlQ2hhdEhlbHBlcnMgPSB7XG4gIC8qKiBDdXJyZW50IG1lc3NhZ2VzIGluIHRoZSBjaGF0ICovXG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIC8qKiBUaGUgZXJyb3Igb2JqZWN0IG9mIHRoZSBBUEkgcmVxdWVzdCAqL1xuICBlcnJvcjogdW5kZWZpbmVkIHwgRXJyb3I7XG4gIC8qKlxuICAgKiBBcHBlbmQgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICogdGhlIGFzc2lzdGFudCdzIHJlc3BvbnNlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBhcHBlbmRcbiAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIEFQSSBjYWxsXG4gICAqL1xuICBhcHBlbmQ6IChcbiAgICBtZXNzYWdlOiBNZXNzYWdlIHwgQ3JlYXRlTWVzc2FnZSxcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIFJlbG9hZCB0aGUgbGFzdCBBSSBjaGF0IHJlc3BvbnNlIGZvciB0aGUgZ2l2ZW4gY2hhdCBoaXN0b3J5LiBJZiB0aGUgbGFzdFxuICAgKiBtZXNzYWdlIGlzbid0IGZyb20gdGhlIGFzc2lzdGFudCwgaXQgd2lsbCByZXF1ZXN0IHRoZSBBUEkgdG8gZ2VuZXJhdGUgYVxuICAgKiBuZXcgcmVzcG9uc2UuXG4gICAqL1xuICByZWxvYWQ6IChcbiAgICBjaGF0UmVxdWVzdE9wdGlvbnM/OiBDaGF0UmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYG1lc3NhZ2VzYCBzdGF0ZSBsb2NhbGx5LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvXG4gICAqIGVkaXQgdGhlIG1lc3NhZ2VzIG9uIHRoZSBjbGllbnQsIGFuZCB0aGVuIHRyaWdnZXIgdGhlIGByZWxvYWRgIG1ldGhvZFxuICAgKiBtYW51YWxseSB0byByZWdlbmVyYXRlIHRoZSBBSSByZXNwb25zZS5cbiAgICovXG4gIHNldE1lc3NhZ2VzOiAobWVzc2FnZXM6IE1lc3NhZ2VbXSkgPT4gdm9pZDtcbiAgLyoqIFRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBpbnB1dDogc3RyaW5nO1xuICAvKiogc2V0U3RhdGUtcG93ZXJlZCBtZXRob2QgdG8gdXBkYXRlIHRoZSBpbnB1dCB2YWx1ZSAqL1xuICBzZXRJbnB1dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIC8qKiBBbiBpbnB1dC90ZXh0YXJlYS1yZWFkeSBvbkNoYW5nZSBoYW5kbGVyIHRvIGNvbnRyb2wgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCAqL1xuICBoYW5kbGVJbnB1dENoYW5nZTogKFxuICAgIGU6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG4gIC8qKiBGb3JtIHN1Ym1pc3Npb24gaGFuZGxlciB0byBhdXRvbWF0aWNhbGx5IHJlc2V0IGlucHV0IGFuZCBhcHBlbmQgYSB1c2VyIG1lc3NhZ2UgKi9cbiAgaGFuZGxlU3VibWl0OiAoXG4gICAgZTogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgY2hhdFJlcXVlc3RPcHRpb25zPzogQ2hhdFJlcXVlc3RPcHRpb25zLFxuICApID0+IHZvaWQ7XG4gIG1ldGFkYXRhPzogT2JqZWN0O1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkO1xufTtcblxudHlwZSBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uID0gKHBheWxvYWQ6IHtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59KSA9PiBQcm9taXNlPGV4cGVyaW1lbnRhbF9TdHJlYW1pbmdSZWFjdFJlc3BvbnNlPjtcblxuY29uc3QgZ2V0U3RyZWFtZWRSZXNwb25zZSA9IGFzeW5jIChcbiAgYXBpOiBzdHJpbmcgfCBTdHJlYW1pbmdSZWFjdFJlc3BvbnNlQWN0aW9uLFxuICBjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QsXG4gIG11dGF0ZTogS2V5ZWRNdXRhdG9yPE1lc3NhZ2VbXT4sXG4gIG11dGF0ZVN0cmVhbURhdGE6IEtleWVkTXV0YXRvcjxKU09OVmFsdWVbXSB8IHVuZGVmaW5lZD4sXG4gIGV4aXN0aW5nRGF0YTogSlNPTlZhbHVlW10gfCB1bmRlZmluZWQsXG4gIGV4dHJhTWV0YWRhdGFSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8YW55PixcbiAgbWVzc2FnZXNSZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8TWVzc2FnZVtdPixcbiAgYWJvcnRDb250cm9sbGVyUmVmOiBSZWFjdC5NdXRhYmxlUmVmT2JqZWN0PEFib3J0Q29udHJvbGxlciB8IG51bGw+LFxuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcixcbiAgb25GaW5pc2g/OiAobWVzc2FnZTogTWVzc2FnZSkgPT4gdm9pZCxcbiAgb25SZXNwb25zZT86IChyZXNwb25zZTogUmVzcG9uc2UpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+LFxuICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzPzogYm9vbGVhbixcbikgPT4ge1xuICAvLyBEbyBhbiBvcHRpbWlzdGljIHVwZGF0ZSB0byB0aGUgY2hhdCBzdGF0ZSB0byBzaG93IHRoZSB1cGRhdGVkIG1lc3NhZ2VzXG4gIC8vIGltbWVkaWF0ZWx5LlxuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudDtcbiAgbXV0YXRlKGNoYXRSZXF1ZXN0Lm1lc3NhZ2VzLCBmYWxzZSk7XG5cbiAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgPSBzZW5kRXh0cmFNZXNzYWdlRmllbGRzXG4gICAgPyBjaGF0UmVxdWVzdC5tZXNzYWdlc1xuICAgIDogY2hhdFJlcXVlc3QubWVzc2FnZXMubWFwKFxuICAgICAgICAoeyByb2xlLCBjb250ZW50LCBuYW1lLCBmdW5jdGlvbl9jYWxsLCB0b29sX2NhbGxzLCB0b29sX2NhbGxfaWQgfSkgPT4gKHtcbiAgICAgICAgICByb2xlLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgIC4uLihuYW1lICE9PSB1bmRlZmluZWQgJiYgeyBuYW1lIH0pLFxuICAgICAgICAgIC4uLihmdW5jdGlvbl9jYWxsICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jYWxscyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgICAgIHRvb2xfY2FsbHM6IHRvb2xfY2FsbHMsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICBpZiAodHlwZW9mIGFwaSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGFyZSBoYW5kbGluZyBhIFNlcnZlciBBY3Rpb24uIE5vIGNvbXBsZXggbW9kZSBoYW5kbGluZyBuZWVkZWQuXG5cbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZTogTWVzc2FnZSA9IHtcbiAgICAgIGlkOiByZXBseUlkLFxuICAgICAgY3JlYXRlZEF0LFxuICAgICAgY29udGVudDogJycsXG4gICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICB9O1xuXG4gICAgYXN5bmMgZnVuY3Rpb24gcmVhZFJvdyhwcm9taXNlOiBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+KSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQsIHVpLCBuZXh0IH0gPSBhd2FpdCBwcm9taXNlO1xuXG4gICAgICAvLyBUT0RPOiBIYW5kbGUgZnVuY3Rpb24gY2FsbHMuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ2NvbnRlbnQnXSA9IGNvbnRlbnQ7XG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ3VpJ10gPSBhd2FpdCB1aTtcblxuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgeyAuLi5yZXNwb25zZU1lc3NhZ2UgfV0sIGZhbHNlKTtcblxuICAgICAgaWYgKG5leHQpIHtcbiAgICAgICAgYXdhaXQgcmVhZFJvdyhuZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcHJvbWlzZSA9IGFwaSh7XG4gICAgICAgIG1lc3NhZ2VzOiBjb25zdHJ1Y3RlZE1lc3NhZ2VzUGF5bG9hZCBhcyBNZXNzYWdlW10sXG4gICAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICB9KSBhcyBQcm9taXNlPFJlYWN0UmVzcG9uc2VSb3c+O1xuICAgICAgYXdhaXQgcmVhZFJvdyhwcm9taXNlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBwcmV2aW91cyBtZXNzYWdlcyBpZiB0aGUgcmVxdWVzdCBmYWlscy5cbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIGlmIChvbkZpbmlzaCkge1xuICAgICAgb25GaW5pc2gocmVzcG9uc2VNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VNZXNzYWdlO1xuICB9XG5cbiAgcmV0dXJuIGF3YWl0IGNhbGxDaGF0QXBpKHtcbiAgICBhcGksXG4gICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgIGJvZHk6IHtcbiAgICAgIGRhdGE6IGNoYXRSZXF1ZXN0LmRhdGEsXG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmJvZHksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QuZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYge1xuICAgICAgICBmdW5jdGlvbnM6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyxcbiAgICAgIH0pLFxuICAgICAgLi4uKGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IGNoYXRSZXF1ZXN0LmZ1bmN0aW9uX2NhbGwsXG4gICAgICB9KSxcbiAgICAgIC4uLihjaGF0UmVxdWVzdC50b29scyAhPT0gdW5kZWZpbmVkICYmIHtcbiAgICAgICAgdG9vbHM6IGNoYXRSZXF1ZXN0LnRvb2xzLFxuICAgICAgfSksXG4gICAgICAuLi4oY2hhdFJlcXVlc3QudG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7XG4gICAgICAgIHRvb2xfY2hvaWNlOiBjaGF0UmVxdWVzdC50b29sX2Nob2ljZSxcbiAgICAgIH0pLFxuICAgIH0sXG4gICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuaGVhZGVycyxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0Lm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgfSxcbiAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LFxuICAgIGFwcGVuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgbWVzc2FnZV0sIGZhbHNlKTtcbiAgICB9LFxuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpIHtcbiAgICAgIG11dGF0ZShwcmV2aW91c01lc3NhZ2VzLCBmYWxzZSk7XG4gICAgfSxcbiAgICBvblJlc3BvbnNlLFxuICAgIG9uVXBkYXRlKG1lcmdlZCwgZGF0YSkge1xuICAgICAgbXV0YXRlKFsuLi5jaGF0UmVxdWVzdC5tZXNzYWdlcywgLi4ubWVyZ2VkXSwgZmFsc2UpO1xuICAgICAgbXV0YXRlU3RyZWFtRGF0YShbLi4uKGV4aXN0aW5nRGF0YSB8fCBbXSksIC4uLihkYXRhIHx8IFtdKV0sIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uRmluaXNoLFxuICAgIGdlbmVyYXRlSWQsXG4gIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYXQoe1xuICBhcGkgPSAnL2FwaS9jaGF0JyxcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gJycsXG4gIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZCA9IG5hbm9pZCxcbn06IE9taXQ8VXNlQ2hhdE9wdGlvbnMsICdhcGknPiAmIHtcbiAgYXBpPzogc3RyaW5nIHwgU3RyZWFtaW5nUmVhY3RSZXNwb25zZUFjdGlvbjtcbiAga2V5Pzogc3RyaW5nO1xufSA9IHt9KTogVXNlQ2hhdEhlbHBlcnMge1xuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgdGhlIGNoYXQgaWYgbm90IHByb3ZpZGVkLlxuICBjb25zdCBob29rSWQgPSB1c2VJZCgpO1xuICBjb25zdCBpZEtleSA9IGlkID8/IGhvb2tJZDtcbiAgY29uc3QgY2hhdEtleSA9IHR5cGVvZiBhcGkgPT09ICdzdHJpbmcnID8gW2FwaSwgaWRLZXldIDogaWRLZXk7XG5cbiAgLy8gU3RvcmUgYSBlbXB0eSBhcnJheSBhcyB0aGUgaW5pdGlhbCBtZXNzYWdlc1xuICAvLyAoaW5zdGVhZCBvZiB1c2luZyBhIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIHRoYXQgZ2V0cyByZS1jcmVhdGVkIGVhY2ggdGltZSlcbiAgLy8gdG8gYXZvaWQgcmUtcmVuZGVyczpcbiAgY29uc3QgW2luaXRpYWxNZXNzYWdlc0ZhbGxiYWNrXSA9IHVzZVN0YXRlKFtdKTtcblxuICAvLyBTdG9yZSB0aGUgY2hhdCBzdGF0ZSBpbiBTV1IsIHVzaW5nIHRoZSBjaGF0SWQgYXMgdGhlIGtleSB0byBzaGFyZSBzdGF0ZXMuXG4gIGNvbnN0IHsgZGF0YTogbWVzc2FnZXMsIG11dGF0ZSB9ID0gdXNlU1dSPE1lc3NhZ2VbXT4oXG4gICAgW2NoYXRLZXksICdtZXNzYWdlcyddLFxuICAgIG51bGwsXG4gICAgeyBmYWxsYmFja0RhdGE6IGluaXRpYWxNZXNzYWdlcyA/PyBpbml0aWFsTWVzc2FnZXNGYWxsYmFjayB9LFxuICApO1xuXG4gIC8vIFdlIHN0b3JlIGxvYWRpbmcgc3RhdGUgaW4gYW5vdGhlciBob29rIHRvIHN5bmMgbG9hZGluZyBzdGF0ZXMgYWNyb3NzIGhvb2sgaW52b2NhdGlvbnNcbiAgY29uc3QgeyBkYXRhOiBpc0xvYWRpbmcgPSBmYWxzZSwgbXV0YXRlOiBtdXRhdGVMb2FkaW5nIH0gPSB1c2VTV1I8Ym9vbGVhbj4oXG4gICAgW2NoYXRLZXksICdsb2FkaW5nJ10sXG4gICAgbnVsbCxcbiAgKTtcblxuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSPFxuICAgIEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkXG4gID4oW2NoYXRLZXksICdzdHJlYW1EYXRhJ10sIG51bGwpO1xuXG4gIGNvbnN0IHsgZGF0YTogZXJyb3IgPSB1bmRlZmluZWQsIG11dGF0ZTogc2V0RXJyb3IgfSA9IHVzZVNXUjxcbiAgICB1bmRlZmluZWQgfCBFcnJvclxuICA+KFtjaGF0S2V5LCAnZXJyb3InXSwgbnVsbCk7XG5cbiAgLy8gS2VlcCB0aGUgbGF0ZXN0IG1lc3NhZ2VzIGluIGEgcmVmLlxuICBjb25zdCBtZXNzYWdlc1JlZiA9IHVzZVJlZjxNZXNzYWdlW10+KG1lc3NhZ2VzIHx8IFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMgfHwgW107XG4gIH0sIFttZXNzYWdlc10pO1xuXG4gIC8vIEFib3J0IGNvbnRyb2xsZXIgdG8gY2FuY2VsIHRoZSBjdXJyZW50IEFQSSBjYWxsLlxuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWY8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICB9KTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHksXG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG5cbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcih1bmRlZmluZWQpO1xuXG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG5cbiAgICAgICAgYXdhaXQgcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICAgICAgICAgIGdldFN0cmVhbWVkUmVzcG9uc2U6ICgpID0+XG4gICAgICAgICAgICBnZXRTdHJlYW1lZFJlc3BvbnNlKFxuICAgICAgICAgICAgICBhcGksXG4gICAgICAgICAgICAgIGNoYXRSZXF1ZXN0LFxuICAgICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICAgICAgICAgIHN0cmVhbURhdGEhLFxuICAgICAgICAgICAgICBleHRyYU1ldGFkYXRhUmVmLFxuICAgICAgICAgICAgICBtZXNzYWdlc1JlZixcbiAgICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLFxuICAgICAgICAgICAgICBnZW5lcmF0ZUlkLFxuICAgICAgICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgICAgICAgb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0OiBjaGF0UmVxdWVzdFBhcmFtID0+IHtcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0ID0gY2hhdFJlcXVlc3RQYXJhbTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgICAgIGlmICgoZXJyIGFzIGFueSkubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRFcnJvcihlcnIgYXMgRXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgbXV0YXRlTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgICAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICBnZW5lcmF0ZUlkLFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKFxuICAgICAgbWVzc2FnZTogTWVzc2FnZSB8IENyZWF0ZU1lc3NhZ2UsXG4gICAgICB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGZ1bmN0aW9ucyxcbiAgICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgdG9vbHMsXG4gICAgICAgIHRvb2xfY2hvaWNlLFxuICAgICAgICBkYXRhLFxuICAgICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgKSA9PiB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHtcbiAgICAgICAgbWVzc2FnZS5pZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2hhdFJlcXVlc3Q6IENoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5jb25jYXQobWVzc2FnZSBhcyBNZXNzYWdlKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uKGZ1bmN0aW9ucyAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25zIH0pLFxuICAgICAgICAuLi4oZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkICYmIHsgZnVuY3Rpb25fY2FsbCB9KSxcbiAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgLi4uKHRvb2xfY2hvaWNlICE9PSB1bmRlZmluZWQgJiYgeyB0b29sX2Nob2ljZSB9KSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgfSxcbiAgICBbdHJpZ2dlclJlcXVlc3QsIGdlbmVyYXRlSWRdLFxuICApO1xuXG4gIGNvbnN0IHJlbG9hZCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh7XG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2UsXG4gICAgfTogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30pID0+IHtcbiAgICAgIGlmIChtZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIC8vIFJlbW92ZSBsYXN0IGFzc2lzdGFudCBtZXNzYWdlIGFuZCByZXRyeSBsYXN0IHVzZXIgbWVzc2FnZS5cbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudC5zbGljZSgwLCAtMSksXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zICE9PSB1bmRlZmluZWQgJiYgeyBmdW5jdGlvbnMgfSksXG4gICAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgICAgLi4uKHRvb2xzICE9PSB1bmRlZmluZWQgJiYgeyB0b29scyB9KSxcbiAgICAgICAgICAuLi4odG9vbF9jaG9pY2UgIT09IHVuZGVmaW5lZCAmJiB7IHRvb2xfY2hvaWNlIH0pLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0OiBDaGF0UmVxdWVzdCA9IHtcbiAgICAgICAgbWVzc2FnZXM6IG1lc3NhZ2VzUmVmLmN1cnJlbnQsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLihmdW5jdGlvbnMgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9ucyB9KSxcbiAgICAgICAgLi4uKGZ1bmN0aW9uX2NhbGwgIT09IHVuZGVmaW5lZCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSksXG4gICAgICAgIC4uLih0b29scyAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbHMgfSksXG4gICAgICAgIC4uLih0b29sX2Nob2ljZSAhPT0gdW5kZWZpbmVkICYmIHsgdG9vbF9jaG9pY2UgfSksXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0XSxcbiAgKTtcblxuICBjb25zdCBzdG9wID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQuYWJvcnQoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrKFxuICAgIChtZXNzYWdlczogTWVzc2FnZVtdKSA9PiB7XG4gICAgICBtdXRhdGUobWVzc2FnZXMsIGZhbHNlKTtcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlcztcbiAgICB9LFxuICAgIFttdXRhdGVdLFxuICApO1xuXG4gIC8vIElucHV0IHN0YXRlIGFuZCBoYW5kbGVycy5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChcbiAgICAgIGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgICAgb3B0aW9uczogQ2hhdFJlcXVlc3RPcHRpb25zID0ge30sXG4gICAgICBtZXRhZGF0YT86IE9iamVjdCxcbiAgICApID0+IHtcbiAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LFxuICAgICAgICAgIC4uLm1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoIWlucHV0KSByZXR1cm47XG5cbiAgICAgIGFwcGVuZChcbiAgICAgICAge1xuICAgICAgICAgIGNvbnRlbnQ6IGlucHV0LFxuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICApO1xuICAgICAgc2V0SW5wdXQoJycpO1xuICAgIH0sXG4gICAgW2lucHV0LCBhcHBlbmRdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBtZXNzYWdlcyB8fCBbXSxcbiAgICBlcnJvcixcbiAgICBhcHBlbmQsXG4gICAgcmVsb2FkLFxuICAgIHN0b3AsXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgaGFuZGxlU3VibWl0LFxuICAgIGlzTG9hZGluZyxcbiAgICBkYXRhOiBzdHJlYW1EYXRhLFxuICB9O1xufVxuIiwiaW1wb3J0IHtcbiAgQXNzaXN0YW50TWVzc2FnZSxcbiAgRGF0YU1lc3NhZ2UsXG4gIEZ1bmN0aW9uQ2FsbCxcbiAgSlNPTlZhbHVlLFxuICBUb29sQ2FsbCxcbn0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBTdHJlYW1TdHJpbmcgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1QYXJ0PENPREUgZXh0ZW5kcyBzdHJpbmcsIE5BTUUgZXh0ZW5kcyBzdHJpbmcsIFRZUEU+IHtcbiAgY29kZTogQ09ERTtcbiAgbmFtZTogTkFNRTtcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7IHR5cGU6IE5BTUU7IHZhbHVlOiBUWVBFIH07XG59XG5cbmNvbnN0IHRleHRTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcwJywgJ3RleHQnLCBzdHJpbmc+ID0ge1xuICBjb2RlOiAnMCcsXG4gIG5hbWU6ICd0ZXh0JyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiAndGV4dCcsIHZhbHVlIH07XG4gIH0sXG59O1xuXG5jb25zdCBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnMScsXG4gICdmdW5jdGlvbl9jYWxsJyxcbiAgeyBmdW5jdGlvbl9jYWxsOiBGdW5jdGlvbkNhbGwgfVxuPiA9IHtcbiAgY29kZTogJzEnLFxuICBuYW1lOiAnZnVuY3Rpb25fY2FsbCcsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ2Z1bmN0aW9uX2NhbGwnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS5mdW5jdGlvbl9jYWxsID09IG51bGwgfHxcbiAgICAgICEoJ25hbWUnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICAhKCdhcmd1bWVudHMnIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSAnc3RyaW5nJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdmdW5jdGlvbl9jYWxsJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgZnVuY3Rpb25fY2FsbDogRnVuY3Rpb25DYWxsIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PCcyJywgJ2RhdGEnLCBBcnJheTxKU09OVmFsdWU+PiA9IHtcbiAgY29kZTogJzInLFxuICBuYW1lOiAnZGF0YScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IHR5cGU6ICdkYXRhJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGVycm9yU3RyZWFtUGFydDogU3RyZWFtUGFydDwnMycsICdlcnJvcicsIHN0cmluZz4gPSB7XG4gIGNvZGU6ICczJyxcbiAgbmFtZTogJ2Vycm9yJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJlcnJvclwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogJ2Vycm9yJywgdmFsdWUgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNCcsXG4gICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gIEFzc2lzdGFudE1lc3NhZ2Vcbj4gPSB7XG4gIGNvZGU6ICc0JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9tZXNzYWdlJyxcbiAgcGFyc2U6ICh2YWx1ZTogSlNPTlZhbHVlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fFxuICAgICAgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fFxuICAgICAgISgnaWQnIGluIHZhbHVlKSB8fFxuICAgICAgISgncm9sZScgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdjb250ZW50JyBpbiB2YWx1ZSkgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5pZCAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZS5yb2xlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdmFsdWUucm9sZSAhPT0gJ2Fzc2lzdGFudCcgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8XG4gICAgICAhdmFsdWUuY29udGVudC5ldmVyeShcbiAgICAgICAgaXRlbSA9PlxuICAgICAgICAgIGl0ZW0gIT0gbnVsbCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICd0eXBlJyBpbiBpdGVtICYmXG4gICAgICAgICAgaXRlbS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgICAndGV4dCcgaW4gaXRlbSAmJlxuICAgICAgICAgIGl0ZW0udGV4dCAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIGl0ZW0udGV4dCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAndmFsdWUnIGluIGl0ZW0udGV4dCAmJlxuICAgICAgICAgIHR5cGVvZiBpdGVtLnRleHQudmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdhc3Npc3RhbnRfbWVzc2FnZScsXG4gICAgICB2YWx1ZTogdmFsdWUgYXMgQXNzaXN0YW50TWVzc2FnZSxcbiAgICB9O1xuICB9LFxufTtcblxuY29uc3QgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0OiBTdHJlYW1QYXJ0PFxuICAnNScsXG4gICdhc3Npc3RhbnRfY29udHJvbF9kYXRhJyxcbiAge1xuICAgIHRocmVhZElkOiBzdHJpbmc7XG4gICAgbWVzc2FnZUlkOiBzdHJpbmc7XG4gIH1cbj4gPSB7XG4gIGNvZGU6ICc1JyxcbiAgbmFtZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICBwYXJzZTogKHZhbHVlOiBKU09OVmFsdWUpID0+IHtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAhKCd0aHJlYWRJZCcgaW4gdmFsdWUpIHx8XG4gICAgICAhKCdtZXNzYWdlSWQnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gJ3N0cmluZydcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdGhyZWFkSWQ6IHZhbHVlLnRocmVhZElkLFxuICAgICAgICBtZXNzYWdlSWQ6IHZhbHVlLm1lc3NhZ2VJZCxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmNvbnN0IGRhdGFNZXNzYWdlU3RyZWFtUGFydDogU3RyZWFtUGFydDwnNicsICdkYXRhX21lc3NhZ2UnLCBEYXRhTWVzc2FnZT4gPSB7XG4gIGNvZGU6ICc2JyxcbiAgbmFtZTogJ2RhdGFfbWVzc2FnZScsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3JvbGUnIGluIHZhbHVlKSB8fFxuICAgICAgISgnZGF0YScgaW4gdmFsdWUpIHx8XG4gICAgICB0eXBlb2YgdmFsdWUucm9sZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgIHZhbHVlLnJvbGUgIT09ICdkYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJkYXRhX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInJvbGVcIiBhbmQgXCJkYXRhXCIgcHJvcGVydHkuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdkYXRhX21lc3NhZ2UnLFxuICAgICAgdmFsdWU6IHZhbHVlIGFzIERhdGFNZXNzYWdlLFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCB0b29sQ2FsbFN0cmVhbVBhcnQ6IFN0cmVhbVBhcnQ8XG4gICc3JyxcbiAgJ3Rvb2xfY2FsbHMnLFxuICB7IHRvb2xfY2FsbHM6IFRvb2xDYWxsW10gfVxuPiA9IHtcbiAgY29kZTogJzcnLFxuICBuYW1lOiAndG9vbF9jYWxscycsXG4gIHBhcnNlOiAodmFsdWU6IEpTT05WYWx1ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHZhbHVlID09IG51bGwgfHxcbiAgICAgIHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICEoJ3Rvb2xfY2FsbHMnIGluIHZhbHVlKSB8fFxuICAgICAgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09ICdvYmplY3QnIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHxcbiAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8XG4gICAgICB2YWx1ZS50b29sX2NhbGxzLnNvbWUodGMgPT4ge1xuICAgICAgICB0YyA9PSBudWxsIHx8XG4gICAgICAgICAgdHlwZW9mIHRjICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICEoJ2lkJyBpbiB0YykgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuaWQgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgndHlwZScgaW4gdGMpIHx8XG4gICAgICAgICAgdHlwZW9mIHRjLnR5cGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgISgnZnVuY3Rpb24nIGluIHRjKSB8fFxuICAgICAgICAgIHRjLmZ1bmN0aW9uID09IG51bGwgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgISgnYXJndW1lbnRzJyBpbiB0Yy5mdW5jdGlvbikgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSAnc3RyaW5nJztcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0b29sX2NhbGxzJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSBhcyB1bmtub3duIGFzIHsgdG9vbF9jYWxsczogVG9vbENhbGxbXSB9LFxuICAgIH07XG4gIH0sXG59O1xuXG5jb25zdCBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuXSBhcyBjb25zdDtcblxuLy8gdW5pb24gdHlwZSBvZiBhbGwgc3RyZWFtIHBhcnRzXG50eXBlIFN0cmVhbVBhcnRzID1cbiAgfCB0eXBlb2YgdGV4dFN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydFxuICB8IHR5cGVvZiBkYXRhU3RyZWFtUGFydFxuICB8IHR5cGVvZiBlcnJvclN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnRcbiAgfCB0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0XG4gIHwgdHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydFxuICB8IHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnQ7XG5cbi8qKlxuICogTWFwcyB0aGUgdHlwZSBvZiBhIHN0cmVhbSBwYXJ0IHRvIGl0cyB2YWx1ZSB0eXBlLlxuICovXG50eXBlIFN0cmVhbVBhcnRWYWx1ZVR5cGUgPSB7XG4gIFtQIGluIFN0cmVhbVBhcnRzIGFzIFBbJ25hbWUnXV06IFJldHVyblR5cGU8UFsncGFyc2UnXT5bJ3ZhbHVlJ107XG59O1xuXG5leHBvcnQgdHlwZSBTdHJlYW1QYXJ0VHlwZSA9XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgdGV4dFN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBkYXRhU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiBlcnJvclN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQucGFyc2U+XG4gIHwgUmV0dXJuVHlwZTx0eXBlb2YgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LnBhcnNlPlxuICB8IFJldHVyblR5cGU8dHlwZW9mIGRhdGFNZXNzYWdlU3RyZWFtUGFydC5wYXJzZT5cbiAgfCBSZXR1cm5UeXBlPHR5cGVvZiB0b29sQ2FsbFN0cmVhbVBhcnQucGFyc2U+O1xuXG5leHBvcnQgY29uc3Qgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBtYXAgb2YgcHJlZml4ZXMgZm9yIGRhdGEgaW4gdGhlIHN0cmVhbVxuICpcbiAqIC0gMDogVGV4dCBmcm9tIHRoZSBMTE0gcmVzcG9uc2VcbiAqIC0gMTogKE9wZW5BSSkgZnVuY3Rpb25fY2FsbCByZXNwb25zZXNcbiAqIC0gMjogY3VzdG9tIEpTT04gYWRkZWQgYnkgdGhlIHVzZXIgdXNpbmcgYERhdGFgXG4gKiAtIDY6IChPcGVuQUkpIHRvb2xfY2FsbCByZXNwb25zZXNcbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgXG4gKiAwOlZlcmNlbFxuICogMDonc1xuICogMDogQUlcbiAqIDA6IEFJXG4gKiAwOiBTREtcbiAqIDA6IGlzIGdyZWF0XG4gKiAwOiFcbiAqIDI6IHsgXCJzb21lSnNvblwiOiBcInZhbHVlXCIgfVxuICogMToge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiZ2V0X2N1cnJlbnRfd2VhdGhlclwiLCBcImFyZ3VtZW50c1wiOiBcIntcXFxcblxcXFxcImxvY2F0aW9uXFxcXFwiOiBcXFxcXCJDaGFybG90dGVzdmlsbGUsIFZpcmdpbmlhXFxcXFwiLFxcXFxuXFxcXFwiZm9ybWF0XFxcXFwiOiBcXFxcXCJjZWxzaXVzXFxcXFwiXFxcXG59XCJ9fVxuICogNjoge1widG9vbF9jYWxsXCI6IHtcImlkXCI6IFwidG9vbF8wXCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcImdldF9jdXJyZW50X3dlYXRoZXJcIiwgXCJhcmd1bWVudHNcIjogXCJ7XFxcXG5cXFxcXCJsb2NhdGlvblxcXFxcIjogXFxcXFwiQ2hhcmxvdHRlc3ZpbGxlLCBWaXJnaW5pYVxcXFxcIixcXFxcblxcXFxcImZvcm1hdFxcXFxcIjogXFxcXFwiY2Vsc2l1c1xcXFxcIlxcXFxufVwifX19XG4gKmBgYFxuICovXG5leHBvcnQgY29uc3QgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAocGFydCA9PiBwYXJ0LmNvZGUpO1xuXG4vKipcbiAqIFBhcnNlcyBhIHN0cmVhbSBwYXJ0IGZyb20gYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGxpbmUgVGhlIHN0cmluZyB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgc3RyZWFtIHBhcnQuXG4gKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIHBhcnNlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHBhcnNlU3RyZWFtUGFydCA9IChsaW5lOiBzdHJpbmcpOiBTdHJlYW1QYXJ0VHlwZSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcblxuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuJyk7XG4gIH1cblxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuXG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXggYXMga2V5b2YgdHlwZW9mIHN0cmVhbVBhcnRzQnlDb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cblxuICBjb25zdCBjb2RlID0gcHJlZml4IGFzIGtleW9mIHR5cGVvZiBzdHJlYW1QYXJ0c0J5Q29kZTtcblxuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlOiBKU09OVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG5cbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIGEgc3RyaW5nIHdpdGggYSBwcmVmaXggZnJvbSB0aGUgYFN0cmVhbUNodW5rUHJlZml4ZXNgLCBKU09OLWlmaWVzIGl0LFxuICogYW5kIGFwcGVuZHMgYSBuZXcgbGluZS5cbiAqXG4gKiBJdCBlbnN1cmVzIHR5cGUtc2FmZXR5IGZvciB0aGUgcGFydCB0eXBlIGFuZCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQ8VCBleHRlbmRzIGtleW9mIFN0cmVhbVBhcnRWYWx1ZVR5cGU+KFxuICB0eXBlOiBULFxuICB2YWx1ZTogU3RyZWFtUGFydFZhbHVlVHlwZVtUXSxcbik6IFN0cmVhbVN0cmluZyB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKHBhcnQgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcblxuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XFxuYDtcbn1cbiIsImltcG9ydCB7IFN0cmVhbVBhcnRUeXBlLCBwYXJzZVN0cmVhbVBhcnQgfSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbmNvbnN0IE5FV0xJTkUgPSAnXFxuJy5jaGFyQ29kZUF0KDApO1xuXG4vLyBjb25jYXRlbmF0ZXMgYWxsIHRoZSBjaHVua3MgaW50byBhIHNpbmdsZSBVaW50OEFycmF5XG5mdW5jdGlvbiBjb25jYXRDaHVua3MoY2h1bmtzOiBVaW50OEFycmF5W10sIHRvdGFsTGVuZ3RoOiBudW1iZXIpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gIGxldCBvZmZzZXQgPSAwO1xuICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgIGNvbmNhdGVuYXRlZENodW5rcy5zZXQoY2h1bmssIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGNodW5rLmxlbmd0aDtcbiAgfVxuICBjaHVua3MubGVuZ3RoID0gMDtcblxuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKFxuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PixcbiAge1xuICAgIGlzQWJvcnRlZCxcbiAgfToge1xuICAgIGlzQWJvcnRlZD86ICgpID0+IGJvb2xlYW47XG4gIH0gPSB7fSxcbik6IEFzeW5jR2VuZXJhdG9yPFN0cmVhbVBhcnRUeXBlPiB7XG4gIC8vIGltcGxlbWVudGF0aW9uIG5vdGU6IHRoaXMgc2xpZ2h0bHkgbW9yZSBjb21wbGV4IGFsZ29yaXRobSBpcyByZXF1aXJlZFxuICAvLyB0byBwYXNzIHRoZSB0ZXN0cyBpbiB0aGUgZWRnZSBlbnZpcm9ubWVudC5cblxuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rczogVWludDhBcnJheVtdID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIG5vdCBhIG5ld2xpbmUsIHdlIGhhdmUgbm90IHJlYWQgdGhlIHdob2xlIEpTT04gdmFsdWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrOyAvLyB3ZSBoYXZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgc3RyZWFtXG4gICAgfVxuXG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcblxuICAgIGNvbnN0IHN0cmVhbVBhcnRzID0gZGVjb2RlclxuICAgICAgLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pXG4gICAgICAuc3BsaXQoJ1xcbicpXG4gICAgICAuZmlsdGVyKGxpbmUgPT4gbGluZSAhPT0gJycpIC8vIHNwbGl0dGluZyBsZWF2ZXMgYW4gZW1wdHkgc3RyaW5nIGF0IHRoZSBlbmRcbiAgICAgIC5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcblxuICAgIGZvciAoY29uc3Qgc3RyZWFtUGFydCBvZiBzdHJlYW1QYXJ0cykge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICBpZiAoaXNBYm9ydGVkPy4oKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gJ25hbm9pZC9ub24tc2VjdXJlJztcbmltcG9ydCB7XG4gIFN0cmVhbVBhcnRUeXBlLFxuICBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxufSBmcm9tICcuL3N0cmVhbS1wYXJ0cyc7XG5cbi8vIDctY2hhcmFjdGVyIHJhbmRvbSBzdHJpbmdcbmV4cG9ydCBjb25zdCBuYW5vaWQgPSBjdXN0b21BbHBoYWJldChcbiAgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6JyxcbiAgNyxcbik7XG5cbi8vIHNpbXBsZSBkZWNvZGVyIHNpZ25hdHVyZXM6XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoXG4gIGNvbXBsZXg6IGZhbHNlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBzdHJpbmc7XG4vLyBjb21wbGV4IGRlY29kZXIgc2lnbmF0dXJlOlxuZnVuY3Rpb24gY3JlYXRlQ2h1bmtEZWNvZGVyKFxuICBjb21wbGV4OiB0cnVlLFxuKTogKGNodW5rOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkKSA9PiBTdHJlYW1QYXJ0VHlwZVtdO1xuLy8gY29tYmluZWQgc2lnbmF0dXJlIGZvciB3aGVuIHRoZSBjbGllbnQgY2FsbHMgdGhpcyBmdW5jdGlvbiB3aXRoIGEgYm9vbGVhbjpcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2RlcihcbiAgY29tcGxleD86IGJvb2xlYW4sXG4pOiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpID0+IFN0cmVhbVBhcnRUeXBlW10gfCBzdHJpbmc7XG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleD86IGJvb2xlYW4pIHtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuXG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY2h1bms6IFVpbnQ4QXJyYXkgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgICAgaWYgKCFjaHVuaykgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChjaHVuazogVWludDhBcnJheSB8IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVyXG4gICAgICAuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KVxuICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgLmZpbHRlcihsaW5lID0+IGxpbmUgIT09ICcnKTsgLy8gc3BsaXR0aW5nIGxlYXZlcyBhbiBlbXB0eSBzdHJpbmcgYXQgdGhlIGVuZFxuXG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVDaHVua0RlY29kZXIgfTtcblxuZXhwb3J0IGNvbnN0IGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAoXG4gIHR5cGU6IGtleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlcyxcbiAgdmFsdWU6IHN0cmluZyxcbik6IHZhbHVlIGlzIFN0cmVhbVN0cmluZyA9PlxuICB2YWx1ZS5zdGFydHNXaXRoKGAke1N0cmVhbVN0cmluZ1ByZWZpeGVzW3R5cGVdfTpgKSAmJiB2YWx1ZS5lbmRzV2l0aCgnXFxuJyk7XG5cbmV4cG9ydCB0eXBlIFN0cmVhbVN0cmluZyA9XG4gIGAkeyh0eXBlb2YgU3RyZWFtU3RyaW5nUHJlZml4ZXMpW2tleW9mIHR5cGVvZiBTdHJlYW1TdHJpbmdQcmVmaXhlc119OiR7c3RyaW5nfVxcbmA7XG5cbi8qKlxuICogQSBoZWFkZXIgc2VudCB0byB0aGUgY2xpZW50IHNvIGl0IGtub3dzIGhvdyB0byBoYW5kbGUgcGFyc2luZyB0aGUgc3RyZWFtIChhcyBhIGRlcHJlY2F0ZWQgdGV4dCByZXNwb25zZSBvciB1c2luZyB0aGUgbmV3IHByZWZpeGVkIHByb3RvY29sKVxuICovXG5leHBvcnQgY29uc3QgQ09NUExFWF9IRUFERVIgPSAnWC1FeHBlcmltZW50YWwtU3RyZWFtLURhdGEnO1xuIiwiaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuL3JlYWQtZGF0YS1zdHJlYW0nO1xuaW1wb3J0IHR5cGUgeyBGdW5jdGlvbkNhbGwsIEpTT05WYWx1ZSwgTWVzc2FnZSwgVG9vbENhbGwgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIFByZWZpeE1hcCA9IHtcbiAgdGV4dD86IE1lc3NhZ2U7XG4gIGZ1bmN0aW9uX2NhbGw/OiBNZXNzYWdlICYge1xuICAgIHJvbGU6ICdhc3Npc3RhbnQnO1xuICAgIGZ1bmN0aW9uX2NhbGw6IEZ1bmN0aW9uQ2FsbDtcbiAgfTtcbiAgdG9vbF9jYWxscz86IE1lc3NhZ2UgJiB7XG4gICAgcm9sZTogJ2Fzc2lzdGFudCc7XG4gICAgdG9vbF9jYWxsczogVG9vbENhbGxbXTtcbiAgfTtcbiAgZGF0YTogSlNPTlZhbHVlW107XG59O1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZCA9IG5hbm9pZCxcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiBuZXcgRGF0ZSgpLFxufToge1xuICByZWFkZXI6IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcjxVaW50OEFycmF5PjtcbiAgYWJvcnRDb250cm9sbGVyUmVmPzoge1xuICAgIGN1cnJlbnQ6IEFib3J0Q29udHJvbGxlciB8IG51bGw7XG4gIH07XG4gIHVwZGF0ZTogKG1lcmdlZDogTWVzc2FnZVtdLCBkYXRhOiBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgb25GaW5pc2g/OiAocHJlZml4TWFwOiBQcmVmaXhNYXApID0+IHZvaWQ7XG4gIGdlbmVyYXRlSWQ/OiAoKSA9PiBzdHJpbmc7XG4gIGdldEN1cnJlbnREYXRlPzogKCkgPT4gRGF0ZTtcbn0pIHtcbiAgY29uc3QgY3JlYXRlZEF0ID0gZ2V0Q3VycmVudERhdGUoKTtcbiAgY29uc3QgcHJlZml4TWFwOiBQcmVmaXhNYXAgPSB7XG4gICAgZGF0YTogW10sXG4gIH07XG5cbiAgLy8gd2UgY3JlYXRlIGEgbWFwIG9mIGVhY2ggcHJlZml4LCBhbmQgZm9yIGVhY2ggcHJlZml4ZWQgbWVzc2FnZSB3ZSBwdXNoIHRvIHRoZSBtYXBcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXJSZWY/LmN1cnJlbnQgPT09IG51bGwsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgaWYgKHByZWZpeE1hcFsndGV4dCddKSB7XG4gICAgICAgIHByZWZpeE1hcFsndGV4dCddID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFsndGV4dCddLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbJ3RleHQnXS5jb250ZW50IHx8ICcnKSArIHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwWyd0ZXh0J10gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXQsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb25fY2FsbCcpIHtcbiAgICAgIHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0LFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsnZnVuY3Rpb25fY2FsbCddO1xuICAgIH1cblxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2U6IE1lc3NhZ2UgfCBudWxsID0gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAndG9vbF9jYWxscycpIHtcbiAgICAgIHByZWZpeE1hcFsndG9vbF9jYWxscyddID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogJycsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIH07XG5cbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFsndG9vbF9jYWxscyddO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnZGF0YScpIHtcbiAgICAgIHByZWZpeE1hcFsnZGF0YSddLnB1c2goLi4udmFsdWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFsndGV4dCddO1xuXG4gICAgLy8gV2UgYWRkIGZ1bmN0aW9uICYgdG9vbCBjYWxscyBhbmQgcmVzcG9uc2UgbWVzc2FnZXMgdG8gdGhlIG1lc3NhZ2VzW10sIGJ1dCBkYXRhIGlzIGl0cyBvd24gdGhpbmdcbiAgICBjb25zdCBtZXJnZWQgPSBbXG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlLFxuICAgICAgdG9vbENhbGxNZXNzYWdlLFxuICAgICAgcmVzcG9uc2VNZXNzYWdlLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pIGFzIE1lc3NhZ2VbXTtcblxuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbJ2RhdGEnXV0pOyAvLyBtYWtlIGEgY29weSBvZiB0aGUgZGF0YSBhcnJheVxuICB9XG5cbiAgb25GaW5pc2g/LihwcmVmaXhNYXApO1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxscyxcbiAgICBdLmZpbHRlcihCb29sZWFuKSBhcyBNZXNzYWdlW10sXG4gICAgZGF0YTogcHJlZml4TWFwLmRhdGEsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBwYXJzZUNvbXBsZXhSZXNwb25zZSB9IGZyb20gJy4vcGFyc2UtY29tcGxleC1yZXNwb25zZSc7XG5pbXBvcnQge1xuICBGdW5jdGlvbkNhbGwsXG4gIElkR2VuZXJhdG9yLFxuICBKU09OVmFsdWUsXG4gIE1lc3NhZ2UsXG4gIFRvb2xDYWxsLFxufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IENPTVBMRVhfSEVBREVSLCBjcmVhdGVDaHVua0RlY29kZXIgfSBmcm9tICcuL3V0aWxzJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNhbGxDaGF0QXBpKHtcbiAgYXBpLFxuICBtZXNzYWdlcyxcbiAgYm9keSxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgYXBwZW5kTWVzc2FnZSxcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIGdlbmVyYXRlSWQsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBtZXNzYWdlczogT21pdDxNZXNzYWdlLCAnaWQnPltdO1xuICBib2R5OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICBjcmVkZW50aWFscz86IFJlcXVlc3RDcmVkZW50aWFscztcbiAgaGVhZGVycz86IEhlYWRlcnNJbml0O1xuICBhYm9ydENvbnRyb2xsZXI/OiAoKSA9PiBBYm9ydENvbnRyb2xsZXIgfCBudWxsO1xuICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmU6ICgpID0+IHZvaWQ7XG4gIGFwcGVuZE1lc3NhZ2U6IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBvblJlc3BvbnNlPzogKHJlc3BvbnNlOiBSZXNwb25zZSkgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uVXBkYXRlOiAobWVyZ2VkOiBNZXNzYWdlW10sIGRhdGE6IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBvbkZpbmlzaD86IChtZXNzYWdlOiBNZXNzYWdlKSA9PiB2b2lkO1xuICBnZW5lcmF0ZUlkOiBJZEdlbmVyYXRvcjtcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICBtZXNzYWdlcyxcbiAgICAgIC4uLmJvZHksXG4gICAgfSksXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIC4uLmhlYWRlcnMsXG4gICAgfSxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlcj8uKCk/LnNpZ25hbCxcbiAgICBjcmVkZW50aWFscyxcbiAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuXG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAoYXdhaXQgcmVzcG9uc2UudGV4dCgpKSB8fCAnRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLicsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuJyk7XG4gIH1cblxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBjb25zdCBpc0NvbXBsZXhNb2RlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSAndHJ1ZSc7XG5cbiAgaWYgKGlzQ29tcGxleE1vZGUpIHtcbiAgICByZXR1cm4gYXdhaXQgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyLFxuICAgICAgYWJvcnRDb250cm9sbGVyUmVmOlxuICAgICAgICBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHVuZGVmaW5lZCxcbiAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICBvbkZpbmlzaChwcmVmaXhNYXApIHtcbiAgICAgICAgaWYgKG9uRmluaXNoICYmIHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICBvbkZpbmlzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZW5lcmF0ZUlkLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNyZWF0ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKGZhbHNlKTtcblxuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogUmVtb3ZlIHRoaXMgb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgbGV0IHN0cmVhbWVkUmVzcG9uc2UgPSAnJztcbiAgICBjb25zdCByZXBseUlkID0gZ2VuZXJhdGVJZCgpO1xuICAgIGxldCByZXNwb25zZU1lc3NhZ2U6IE1lc3NhZ2UgPSB7XG4gICAgICBpZDogcmVwbHlJZCxcbiAgICAgIGNyZWF0ZWRBdCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgfTtcblxuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogUmVtb3ZlIHRoaXMgb25jZSBTdHJlYW0gRGF0YSBpcyBub3QgZXhwZXJpbWVudGFsXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIFVwZGF0ZSB0aGUgY2hhdCBzdGF0ZSB3aXRoIHRoZSBuZXcgbWVzc2FnZSB0b2tlbnMuXG4gICAgICBzdHJlYW1lZFJlc3BvbnNlICs9IGRlY29kZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChzdHJlYW1lZFJlc3BvbnNlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSkge1xuICAgICAgICAvLyBXaGlsZSB0aGUgZnVuY3Rpb24gY2FsbCBpcyBzdHJlYW1pbmcsIGl0IHdpbGwgYmUgYSBzdHJpbmcuXG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZVsnZnVuY3Rpb25fY2FsbCddID0gc3RyZWFtZWRSZXNwb25zZTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtZWRSZXNwb25zZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpIHtcbiAgICAgICAgLy8gV2hpbGUgdGhlIHRvb2wgY2FsbHMgYXJlIHN0cmVhbWluZywgaXQgd2lsbCBiZSBhIHN0cmluZy5cbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlWyd0b29sX2NhbGxzJ10gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzcG9uc2VNZXNzYWdlWydjb250ZW50J10gPSBzdHJlYW1lZFJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmRNZXNzYWdlKHsgLi4ucmVzcG9uc2VNZXNzYWdlIH0pO1xuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBoYXMgYmVlbiBhYm9ydGVkLCBzdG9wIHJlYWRpbmcgdGhlIHN0cmVhbS5cbiAgICAgIGlmIChhYm9ydENvbnRyb2xsZXI/LigpID09PSBudWxsKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1wiZnVuY3Rpb25fY2FsbFwiOicpKSB7XG4gICAgICAvLyBPbmNlIHRoZSBzdHJlYW0gaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBjYWxsIGlzIHBhcnNlZCBpbnRvIGFuIG9iamVjdC5cbiAgICAgIGNvbnN0IHBhcnNlZEZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsID1cbiAgICAgICAgSlNPTi5wYXJzZShzdHJlYW1lZFJlc3BvbnNlKS5mdW5jdGlvbl9jYWxsO1xuXG4gICAgICByZXNwb25zZU1lc3NhZ2VbJ2Z1bmN0aW9uX2NhbGwnXSA9IHBhcnNlZEZ1bmN0aW9uQ2FsbDtcblxuICAgICAgYXBwZW5kTWVzc2FnZSh7IC4uLnJlc3BvbnNlTWVzc2FnZSB9KTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbWVkUmVzcG9uc2Uuc3RhcnRzV2l0aCgne1widG9vbF9jYWxsc1wiOicpKSB7XG4gICAgICAvLyBPbmNlIHRoZSBzdHJlYW0gaXMgY29tcGxldGUsIHRoZSB0b29sIGNhbGxzIGFyZSBwYXJzZWQgaW50byBhbiBhcnJheS5cbiAgICAgIGNvbnN0IHBhcnNlZFRvb2xDYWxsczogVG9vbENhbGxbXSA9XG4gICAgICAgIEpTT04ucGFyc2Uoc3RyZWFtZWRSZXNwb25zZSkudG9vbF9jYWxscztcblxuICAgICAgcmVzcG9uc2VNZXNzYWdlWyd0b29sX2NhbGxzJ10gPSBwYXJzZWRUb29sQ2FsbHM7XG5cbiAgICAgIGFwcGVuZE1lc3NhZ2UoeyAuLi5yZXNwb25zZU1lc3NhZ2UgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChyZXNwb25zZU1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZU1lc3NhZ2U7XG4gIH1cbn1cbiIsImltcG9ydCB7XG4gIENoYXRSZXF1ZXN0LFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgTWVzc2FnZSxcbiAgVG9vbENhbGwsXG59IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzLFxufToge1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlOiAoKSA9PiBQcm9taXNlPFxuICAgIE1lc3NhZ2UgfCB7IG1lc3NhZ2VzOiBNZXNzYWdlW107IGRhdGE6IEpTT05WYWx1ZVtdIH1cbiAgPjtcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsPzogKFxuICAgIGNoYXRNZXNzYWdlczogTWVzc2FnZVtdLFxuICAgIGZ1bmN0aW9uQ2FsbDogRnVuY3Rpb25DYWxsLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGw/OiAoXG4gICAgY2hhdE1lc3NhZ2VzOiBNZXNzYWdlW10sXG4gICAgdG9vbENhbGxzOiBUb29sQ2FsbFtdLFxuICApID0+IFByb21pc2U8dm9pZCB8IENoYXRSZXF1ZXN0PjtcbiAgdXBkYXRlQ2hhdFJlcXVlc3Q6IChjaGF0UmVxdWVzdDogQ2hhdFJlcXVlc3QpID0+IHZvaWQ7XG4gIGdldEN1cnJlbnRNZXNzYWdlczogKCkgPT4gTWVzc2FnZVtdO1xufSkge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFRPRE8tU1RSRUFNREFUQTogVGhpcyBzaG91bGQgYmUgeyAgY29uc3QgeyBtZXNzYWdlczogc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2VzLCBkYXRhIH0gPVxuICAgIC8vIGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UofSBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuXG4gICAgLy8gVXNpbmcgZXhwZXJpbWVudGFsIHN0cmVhbSBkYXRhXG4gICAgaWYgKCdtZXNzYWdlcycgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlLm1lc3NhZ2VzKSB7XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbWVzc2FnZSBoYXMgYSBjb21wbGV0ZSBmdW5jdGlvbiBjYWxsIG9yIHRvb2wgY2FsbFxuICAgICAgICBpZiAoXG4gICAgICAgICAgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgICAobWVzc2FnZS50b29sX2NhbGxzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlLnRvb2xfY2FsbHMgPT09ICdzdHJpbmcnKVxuICAgICAgICApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJ5IHRvIGhhbmRsZSBmdW5jdGlvbiBjYWxsXG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGZ1bmN0aW9uQ2FsbCBpcyBhbiBvYmplY3RcbiAgICAgICAgICAvLyBJZiBub3QsIHdlIGdvdCB0b29sIGNhbGxzIGluc3RlYWQgb2YgZnVuY3Rpb24gY2FsbHNcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29scycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVXNlciBoYW5kbGVzIHRoZSBmdW5jdGlvbiBjYWxsIGluIHRoZWlyIG93biBmdW5jdGlvbkNhbGxIYW5kbGVyLlxuICAgICAgICAgIC8vIFRoZSBcImFyZ3VtZW50c1wiIGtleSBvZiB0aGUgZnVuY3Rpb24gY2FsbCBvYmplY3Qgd2lsbCBzdGlsbCBiZSBhIHN0cmluZyB3aGljaCB3aWxsIGhhdmUgdG8gYmUgcGFyc2VkIGluIHRoZSBmdW5jdGlvbiBoYW5kbGVyLlxuICAgICAgICAgIC8vIElmIHRoZSBcImFyZ3VtZW50c1wiIEpTT04gaXMgbWFsZm9ybWVkIGR1ZSB0byBtb2RlbCBlcnJvciB0aGUgdXNlciB3aWxsIGhhdmUgdG8gaGFuZGxlIHRoYXQgdGhlbXNlbHZlcy5cblxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXMoKSxcbiAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEEgZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3YXMgcmV0dXJuZWQuXG4gICAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gaGFuZGxlIHRvb2wgY2FsbFxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRvb2xDYWxscyBpcyBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgLy8gSWYgbm90LCB3ZSBnb3QgZnVuY3Rpb24gY2FsbHMgaW5zdGVhZCBvZiB0b29sIGNhbGxzXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodG9vbENhbGxzKSB8fFxuICAgICAgICAgICAgdG9vbENhbGxzLnNvbWUodG9vbENhbGwgPT4gdHlwZW9mIHRvb2xDYWxsICE9PSAnb2JqZWN0JylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ2V4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVc2VyIGhhbmRsZXMgdGhlIGZ1bmN0aW9uIGNhbGwgaW4gdGhlaXIgb3duIGZ1bmN0aW9uQ2FsbEhhbmRsZXIuXG4gICAgICAgICAgLy8gVGhlIFwiYXJndW1lbnRzXCIga2V5IG9mIHRoZSBmdW5jdGlvbiBjYWxsIG9iamVjdCB3aWxsIHN0aWxsIGJlIGEgc3RyaW5nIHdoaWNoIHdpbGwgaGF2ZSB0byBiZSBwYXJzZWQgaW4gdGhlIGZ1bmN0aW9uIGhhbmRsZXIuXG4gICAgICAgICAgLy8gSWYgdGhlIFwiYXJndW1lbnRzXCIgSlNPTiBpcyBtYWxmb3JtZWQgZHVlIHRvIG1vZGVsIGVycm9yIHRoZSB1c2VyIHdpbGwgaGF2ZSB0byBoYW5kbGUgdGhhdCB0aGVtc2VsdmVzLlxuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgICBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcblxuICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGRvZXMgbm90IHJldHVybiBhbnl0aGluZyBhcyBhIHJlc3VsdCBvZiB0aGUgZnVuY3Rpb24gY2FsbCwgdGhlIGxvb3Agd2lsbCBicmVhay5cbiAgICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgICAvLyBUaGUgdXBkYXRlZCBjaGF0IHdpdGggZnVuY3Rpb24gY2FsbCByZXNwb25zZSB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gb2YgdGhlIGxvb3AuXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcblxuICAgICAgLy8gVE9ETy1TVFJFQU1EQVRBOiBSZW1vdmUgdGhpcyBvbmNlIFN0cmVhbSBEYXRhIGlzIG5vdCBleHBlcmltZW50YWxcbiAgICAgIGlmIChcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSAnc3RyaW5nJykgJiZcbiAgICAgICAgKHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgIHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSAnc3RyaW5nJylcbiAgICAgICkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUgYW5kIGFyZSBleHBlY3RpbmcgYSBmdW5jdGlvbiBjYWxsLCB0aGUgbWVzc2FnZSBzaG91bGQgaGF2ZSBvbmUsIGlmIG5vdCB3YXJuIGFuZCBjb250aW51ZVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlOiBDaGF0UmVxdWVzdCB8IHZvaWQgPVxuICAgICAgICAgIGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcblxuICAgICAgICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXMgYSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uIGNhbGwsIHRoZSBsb29wIHdpbGwgYnJlYWsuXG4gICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgYXJlIGV4cGVjdGluZyBhIHRvb2wgY2FsbCwgdGhlIG1lc3NhZ2Ugc2hvdWxkIGhhdmUgb25lLCBpZiBub3Qgd2FybiBhbmQgY29udGludWVcbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zJyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2U6IENoYXRSZXF1ZXN0IHwgdm9pZCA9XG4gICAgICAgICAgYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGFzIGEgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBjYWxsLCB0aGUgbG9vcCB3aWxsIGJyZWFrLlxuICAgICAgICBpZiAodG9vbENhbGxSZXNwb25zZSA9PT0gdW5kZWZpbmVkKSBicmVhaztcbiAgICAgICAgLy8gQSBmdW5jdGlvbiBjYWxsIHJlc3BvbnNlIHdhcyByZXR1cm5lZC5cbiAgICAgICAgLy8gVGhlIHVwZGF0ZWQgY2hhdCB3aXRoIGZ1bmN0aW9uIGNhbGwgcmVzcG9uc2Ugd2lsbCBiZSBzZW50IHRvIHRoZSBBUEkgaW4gdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHModG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgZnVuY3Rpb24gY2FsbCBhcmd1bWVudHMgYXJlIHNlbnQgYmFjayB0byB0aGUgQVBJIGFzIGEgc3RyaW5nXG4gICAgICBmdW5jdGlvbiBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMocmVzcG9uc2U6IENoYXRSZXF1ZXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiByZXNwb25zZS5tZXNzYWdlcykge1xuICAgICAgICAgIGlmIChtZXNzYWdlLnRvb2xfY2FsbHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBtZXNzYWdlLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b29sQ2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VJZCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IGNhbGxDb21wbGV0aW9uQXBpIH0gZnJvbSAnLi4vc2hhcmVkL2NhbGwtY29tcGxldGlvbi1hcGknO1xuaW1wb3J0IHtcbiAgSlNPTlZhbHVlLFxuICBSZXF1ZXN0T3B0aW9ucyxcbiAgVXNlQ29tcGxldGlvbk9wdGlvbnMsXG59IGZyb20gJy4uL3NoYXJlZC90eXBlcyc7XG5cbmV4cG9ydCB0eXBlIFVzZUNvbXBsZXRpb25IZWxwZXJzID0ge1xuICAvKiogVGhlIGN1cnJlbnQgY29tcGxldGlvbiByZXN1bHQgKi9cbiAgY29tcGxldGlvbjogc3RyaW5nO1xuICAvKipcbiAgICogU2VuZCBhIG5ldyBwcm9tcHQgdG8gdGhlIEFQSSBlbmRwb2ludCBhbmQgdXBkYXRlIHRoZSBjb21wbGV0aW9uIHN0YXRlLlxuICAgKi9cbiAgY29tcGxldGU6IChcbiAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMsXG4gICkgPT4gUHJvbWlzZTxzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgLyoqIFRoZSBlcnJvciBvYmplY3Qgb2YgdGhlIEFQSSByZXF1ZXN0ICovXG4gIGVycm9yOiB1bmRlZmluZWQgfCBFcnJvcjtcbiAgLyoqXG4gICAqIEFib3J0IHRoZSBjdXJyZW50IEFQSSByZXF1ZXN0IGJ1dCBrZWVwIHRoZSBnZW5lcmF0ZWQgdG9rZW5zLlxuICAgKi9cbiAgc3RvcDogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYGNvbXBsZXRpb25gIHN0YXRlIGxvY2FsbHkuXG4gICAqL1xuICBzZXRDb21wbGV0aW9uOiAoY29tcGxldGlvbjogc3RyaW5nKSA9PiB2b2lkO1xuICAvKiogVGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGlucHV0ICovXG4gIGlucHV0OiBzdHJpbmc7XG4gIC8qKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlICovXG4gIHNldElucHV0OiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+PjtcbiAgLyoqXG4gICAqIEFuIGlucHV0L3RleHRhcmVhLXJlYWR5IG9uQ2hhbmdlIGhhbmRsZXIgdG8gY29udHJvbCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8aW5wdXQgb25DaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfSB2YWx1ZT17aW5wdXR9IC8+XG4gICAqIGBgYFxuICAgKi9cbiAgaGFuZGxlSW5wdXRDaGFuZ2U6IChcbiAgICBlOlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MSW5wdXRFbGVtZW50PlxuICAgICAgfCBSZWFjdC5DaGFuZ2VFdmVudDxIVE1MVGV4dEFyZWFFbGVtZW50PixcbiAgKSA9PiB2b2lkO1xuICAvKipcbiAgICogRm9ybSBzdWJtaXNzaW9uIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSByZXNldCBpbnB1dCBhbmQgYXBwZW5kIGEgdXNlciBtZXNzYWdlXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICogIDxpbnB1dCBvbkNoYW5nZT17aGFuZGxlSW5wdXRDaGFuZ2V9IHZhbHVlPXtpbnB1dH0gLz5cbiAgICogPC9mb3JtPlxuICAgKiBgYGBcbiAgICovXG4gIGhhbmRsZVN1Ym1pdDogKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSA9PiB2b2lkO1xuICAvKiogV2hldGhlciB0aGUgQVBJIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICAvKiogQWRkaXRpb25hbCBkYXRhIGFkZGVkIG9uIHRoZSBzZXJ2ZXIgdmlhIFN0cmVhbURhdGEgKi9cbiAgZGF0YT86IEpTT05WYWx1ZVtdIHwgdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbXBsZXRpb24oe1xuICBhcGkgPSAnL2FwaS9jb21wbGV0aW9uJyxcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gJycsXG4gIGluaXRpYWxJbnB1dCA9ICcnLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG59OiBVc2VDb21wbGV0aW9uT3B0aW9ucyA9IHt9KTogVXNlQ29tcGxldGlvbkhlbHBlcnMge1xuICAvLyBHZW5lcmF0ZSBhbiB1bmlxdWUgaWQgZm9yIHRoZSBjb21wbGV0aW9uIGlmIG5vdCBwcm92aWRlZC5cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgY29tcGxldGlvbklkID0gaWQgfHwgaG9va0lkO1xuXG4gIC8vIFN0b3JlIHRoZSBjb21wbGV0aW9uIHN0YXRlIGluIFNXUiwgdXNpbmcgdGhlIGNvbXBsZXRpb25JZCBhcyB0aGUga2V5IHRvIHNoYXJlIHN0YXRlcy5cbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjxzdHJpbmc+KFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uLFxuICB9KTtcblxuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjxib29sZWFuPihcbiAgICBbY29tcGxldGlvbklkLCAnbG9hZGluZyddLFxuICAgIG51bGwsXG4gICk7XG5cbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjxcbiAgICBKU09OVmFsdWVbXSB8IHVuZGVmaW5lZFxuICA+KFtjb21wbGV0aW9uSWQsICdzdHJlYW1EYXRhJ10sIG51bGwpO1xuXG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5kZWZpbmVkIHwgRXJyb3I+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IGNvbXBsZXRpb24gPSBkYXRhITtcblxuICAvLyBBYm9ydCBjb250cm9sbGVyIHRvIGNhbmNlbCB0aGUgY3VycmVudCBBUEkgY2FsbC5cbiAgY29uc3QgW2Fib3J0Q29udHJvbGxlciwgc2V0QWJvcnRDb250cm9sbGVyXSA9XG4gICAgdXNlU3RhdGU8QWJvcnRDb250cm9sbGVyIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZih7XG4gICAgY3JlZGVudGlhbHMsXG4gICAgaGVhZGVycyxcbiAgICBib2R5LFxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH07XG4gIH0sIFtjcmVkZW50aWFscywgaGVhZGVycywgYm9keV0pO1xuXG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHByb21wdDogc3RyaW5nLCBvcHRpb25zPzogUmVxdWVzdE9wdGlvbnMpID0+XG4gICAgICBjYWxsQ29tcGxldGlvbkFwaSh7XG4gICAgICAgIGFwaSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBjcmVkZW50aWFsczogZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmNyZWRlbnRpYWxzLFxuICAgICAgICBoZWFkZXJzOiB7IC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5oZWFkZXJzLCAuLi5vcHRpb25zPy5oZWFkZXJzIH0sXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgICAuLi5vcHRpb25zPy5ib2R5LFxuICAgICAgICB9LFxuICAgICAgICBzZXRDb21wbGV0aW9uOiBjb21wbGV0aW9uID0+IG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSksXG4gICAgICAgIHNldExvYWRpbmc6IG11dGF0ZUxvYWRpbmcsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgIG9uRmluaXNoLFxuICAgICAgICBvbkVycm9yLFxuICAgICAgICBvbkRhdGE6IGRhdGEgPT4ge1xuICAgICAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLihzdHJlYW1EYXRhIHx8IFtdKSwgLi4uKGRhdGEgfHwgW10pXSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgbXV0YXRlU3RyZWFtRGF0YSxcbiAgICBdLFxuICApO1xuXG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlcikge1xuICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgfVxuICB9LCBbYWJvcnRDb250cm9sbGVyXSk7XG5cbiAgY29uc3Qgc2V0Q29tcGxldGlvbiA9IHVzZUNhbGxiYWNrKFxuICAgIChjb21wbGV0aW9uOiBzdHJpbmcpID0+IHtcbiAgICAgIG11dGF0ZShjb21wbGV0aW9uLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXSxcbiAgKTtcblxuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrPFVzZUNvbXBsZXRpb25IZWxwZXJzWydjb21wbGV0ZSddPihcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF0sXG4gICk7XG5cbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShpbml0aWFsSW5wdXQpO1xuXG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5Gb3JtRXZlbnQ8SFRNTEZvcm1FbGVtZW50PikgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKCFpbnB1dCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIGNvbXBsZXRlKGlucHV0KTtcbiAgICB9LFxuICAgIFtpbnB1dCwgY29tcGxldGVdLFxuICApO1xuXG4gIGNvbnN0IGhhbmRsZUlucHV0Q2hhbmdlID0gKGU6IGFueSkgPT4ge1xuICAgIHNldElucHV0KGUudGFyZ2V0LnZhbHVlKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb24sXG4gICAgY29tcGxldGUsXG4gICAgZXJyb3IsXG4gICAgc2V0Q29tcGxldGlvbixcbiAgICBzdG9wLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IHJlYWREYXRhU3RyZWFtIH0gZnJvbSAnLi9yZWFkLWRhdGEtc3RyZWFtJztcbmltcG9ydCB7IEpTT05WYWx1ZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgQ09NUExFWF9IRUFERVIsIGNyZWF0ZUNodW5rRGVjb2RlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2FsbENvbXBsZXRpb25BcGkoe1xuICBhcGksXG4gIHByb21wdCxcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHNldENvbXBsZXRpb24sXG4gIHNldExvYWRpbmcsXG4gIHNldEVycm9yLFxuICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBvbkRhdGEsXG59OiB7XG4gIGFwaTogc3RyaW5nO1xuICBwcm9tcHQ6IHN0cmluZztcbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG4gIGhlYWRlcnM/OiBIZWFkZXJzSW5pdDtcbiAgYm9keTogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgc2V0Q29tcGxldGlvbjogKGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0TG9hZGluZzogKGxvYWRpbmc6IGJvb2xlYW4pID0+IHZvaWQ7XG4gIHNldEVycm9yOiAoZXJyb3I6IEVycm9yIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xuICBzZXRBYm9ydENvbnRyb2xsZXI6IChhYm9ydENvbnRyb2xsZXI6IEFib3J0Q29udHJvbGxlciB8IG51bGwpID0+IHZvaWQ7XG4gIG9uUmVzcG9uc2U/OiAocmVzcG9uc2U6IFJlc3BvbnNlKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25GaW5pc2g/OiAocHJvbXB0OiBzdHJpbmcsIGNvbXBsZXRpb246IHN0cmluZykgPT4gdm9pZDtcbiAgb25FcnJvcj86IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIG9uRGF0YT86IChkYXRhOiBKU09OVmFsdWVbXSkgPT4gdm9pZDtcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHVuZGVmaW5lZCk7XG5cbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG5cbiAgICAvLyBFbXB0eSB0aGUgY29tcGxldGlvbiBpbW1lZGlhdGVseS5cbiAgICBzZXRDb21wbGV0aW9uKCcnKTtcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGFwaSwge1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgLi4uYm9keSxcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG5cbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoYXdhaXQgcmVzLnRleHQoKSkgfHwgJ0ZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LicpO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgIGNvbnN0IGlzQ29tcGxleE1vZGUgPSByZXMuaGVhZGVycy5nZXQoQ09NUExFWF9IRUFERVIpID09PSAndHJ1ZSc7XG5cbiAgICBpZiAoaXNDb21wbGV4TW9kZSkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyID09PSBudWxsLFxuICAgICAgfSkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dCc6IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdkYXRhJzoge1xuICAgICAgICAgICAgb25EYXRhPy4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29tcGxldGlvbiBzdGF0ZSB3aXRoIHRoZSBuZXcgbWVzc2FnZSB0b2tlbnMuXG4gICAgICAgIHJlc3VsdCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuXG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFib3J0ZWQsIHN0b3AgcmVhZGluZyB0aGUgc3RyZWFtLlxuICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuXG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIElnbm9yZSBhYm9ydCBlcnJvcnMgYXMgdGhleSBhcmUgZXhwZWN0ZWQuXG4gICAgaWYgKChlcnIgYXMgYW55KS5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEVycm9yKGVyciBhcyBFcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzICovXG5cbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcmVhZERhdGFTdHJlYW0gfSBmcm9tICcuLi9zaGFyZWQvcmVhZC1kYXRhLXN0cmVhbSc7XG5pbXBvcnQgeyBNZXNzYWdlIH0gZnJvbSAnLi4vc2hhcmVkL3R5cGVzJztcblxuZXhwb3J0IHR5cGUgQXNzaXN0YW50U3RhdHVzID0gJ2luX3Byb2dyZXNzJyB8ICdhd2FpdGluZ19tZXNzYWdlJztcblxuZXhwb3J0IHR5cGUgVXNlQXNzaXN0YW50SGVscGVycyA9IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IGFycmF5IG9mIGNoYXQgbWVzc2FnZXMuXG4gICAqL1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB0aHJlYWQgSUQuXG4gICAqL1xuICB0aHJlYWRJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZmllbGQuXG4gICAqL1xuICBpbnB1dDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBzZXRTdGF0ZS1wb3dlcmVkIG1ldGhvZCB0byB1cGRhdGUgdGhlIGlucHV0IHZhbHVlLlxuICAgKi9cbiAgc2V0SW5wdXQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVyIGZvciB0aGUgYG9uQ2hhbmdlYCBldmVudCBvZiB0aGUgaW5wdXQgZmllbGQgdG8gY29udHJvbCB0aGUgaW5wdXQncyB2YWx1ZS5cbiAgICovXG4gIGhhbmRsZUlucHV0Q2hhbmdlOiAoXG4gICAgZXZlbnQ6XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+XG4gICAgICB8IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+LFxuICApID0+IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEZvcm0gc3VibWlzc2lvbiBoYW5kbGVyIHRoYXQgYXV0b21hdGljYWxseSByZXNldHMgdGhlIGlucHV0IGZpZWxkIGFuZCBhcHBlbmRzIGEgdXNlciBtZXNzYWdlLlxuICAgKi9cbiAgc3VibWl0TWVzc2FnZTogKFxuICAgIGV2ZW50PzogUmVhY3QuRm9ybUV2ZW50PEhUTUxGb3JtRWxlbWVudD4sXG4gICAgcmVxdWVzdE9wdGlvbnM/OiB7XG4gICAgICBkYXRhPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgICB9LFxuICApID0+IFByb21pc2U8dm9pZD47XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgYXNzaXN0YW50LiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNob3cgYSBsb2FkaW5nIGluZGljYXRvci5cbiAgICovXG4gIHN0YXR1czogQXNzaXN0YW50U3RhdHVzO1xuXG4gIC8qKlxuICAgKiBUaGUgZXJyb3IgdGhyb3duIGR1cmluZyB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgcHJvY2Vzc2luZywgaWYgYW55LlxuICAgKi9cbiAgZXJyb3I6IHVuZGVmaW5lZCB8IHVua25vd247XG59O1xuXG5leHBvcnQgdHlwZSBVc2VBc3Npc3RhbnRPcHRpb25zID0ge1xuICAvKipcbiAgICogVGhlIEFQSSBlbmRwb2ludCB0aGF0IGFjY2VwdHMgYSBgeyB0aHJlYWRJZDogc3RyaW5nIHwgbnVsbDsgbWVzc2FnZTogc3RyaW5nOyB9YCBvYmplY3QgYW5kIHJldHVybnMgYW4gYEFzc2lzdGFudFJlc3BvbnNlYCBzdHJlYW0uXG4gICAqIFRoZSB0aHJlYWRJZCByZWZlcnMgdG8gYW4gZXhpc3RpbmcgdGhyZWFkIHdpdGggbWVzc2FnZXMgKG9yIGlzIGBudWxsYCB0byBjcmVhdGUgYSBuZXcgdGhyZWFkKS5cbiAgICogVGhlIG1lc3NhZ2UgaXMgdGhlIG5leHQgbWVzc2FnZSB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgdGhyZWFkIGFuZCBzZW50IHRvIHRoZSBhc3Npc3RhbnQuXG4gICAqL1xuICBhcGk6IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgSUQgb2YgYW4gZXhpc3RpbmcgdGhyZWFkLlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGEgbmV3IHRocmVhZCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqL1xuICB0aHJlYWRJZD86IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgbGl0ZXJhbCB0aGF0IHNldHMgdGhlIG1vZGUgb2YgY3JlZGVudGlhbHMgdG8gYmUgdXNlZCBvbiB0aGUgcmVxdWVzdC5cbiAgICogRGVmYXVsdHMgdG8gXCJzYW1lLW9yaWdpblwiLlxuICAgKi9cbiAgY3JlZGVudGlhbHM/OiBSZXF1ZXN0Q3JlZGVudGlhbHM7XG5cbiAgLyoqXG4gICAqIEFuIG9wdGlvbmFsIG9iamVjdCBvZiBoZWFkZXJzIHRvIGJlIHBhc3NlZCB0byB0aGUgQVBJIGVuZHBvaW50LlxuICAgKi9cbiAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfCBIZWFkZXJzO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCwgYWRkaXRpb25hbCBib2R5IG9iamVjdCB0byBiZSBwYXNzZWQgdG8gdGhlIEFQSSBlbmRwb2ludC5cbiAgICovXG4gIGJvZHk/OiBvYmplY3Q7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gZXhwZXJpbWVudGFsX3VzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW0sXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxufTogVXNlQXNzaXN0YW50T3B0aW9ucyk6IFVzZUFzc2lzdGFudEhlbHBlcnMge1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKCcnKTtcbiAgY29uc3QgW3RocmVhZElkLCBzZXRUaHJlYWRJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZTxBc3Npc3RhbnRTdGF0dXM+KCdhd2FpdGluZ19tZXNzYWdlJyk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8dW5rbm93biB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChcbiAgICBldmVudDpcbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD5cbiAgICAgIHwgUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTFRleHRBcmVhRWxlbWVudD4sXG4gICkgPT4ge1xuICAgIHNldElucHV0KGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gIH07XG5cbiAgY29uc3Qgc3VibWl0TWVzc2FnZSA9IGFzeW5jIChcbiAgICBldmVudD86IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+LFxuICAgIHJlcXVlc3RPcHRpb25zPzoge1xuICAgICAgZGF0YT86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfSxcbiAgKSA9PiB7XG4gICAgZXZlbnQ/LnByZXZlbnREZWZhdWx0Py4oKTtcblxuICAgIGlmIChpbnB1dCA9PT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZXRTdGF0dXMoJ2luX3Byb2dyZXNzJyk7XG5cbiAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiBbXG4gICAgICAuLi5tZXNzYWdlcyxcbiAgICAgIHsgaWQ6ICcnLCByb2xlOiAndXNlcicsIGNvbnRlbnQ6IGlucHV0IH0sXG4gICAgXSk7XG5cbiAgICBzZXRJbnB1dCgnJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChhcGksIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsIC4uLmhlYWRlcnMgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgLi4uYm9keSxcbiAgICAgICAgLy8gYWx3YXlzIHVzZSB1c2VyLXByb3ZpZGVkIHRocmVhZElkIHdoZW4gYXZhaWxhYmxlOlxuICAgICAgICB0aHJlYWRJZDogdGhyZWFkSWRQYXJhbSA/PyB0aHJlYWRJZCA/PyBudWxsLFxuICAgICAgICBtZXNzYWdlOiBpbnB1dCxcblxuICAgICAgICAvLyBvcHRpb25hbCByZXF1ZXN0IGRhdGE6XG4gICAgICAgIGRhdGE6IHJlcXVlc3RPcHRpb25zPy5kYXRhLFxuICAgICAgfSksXG4gICAgfSk7XG5cbiAgICBpZiAocmVzdWx0LmJvZHkgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS4nKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3VsdC5ib2R5LmdldFJlYWRlcigpLFxuICAgICAgKSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdhc3Npc3RhbnRfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQsXG4gICAgICAgICAgICAgICAgcm9sZTogdmFsdWUucm9sZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZS5jb250ZW50WzBdLnRleHQudmFsdWUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RhdGFfbWVzc2FnZSc6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKG1lc3NhZ2VzID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogdmFsdWUuaWQgPz8gJycsXG4gICAgICAgICAgICAgICAgcm9sZTogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHZhbHVlLmRhdGEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Fzc2lzdGFudF9jb250cm9sX2RhdGEnOiB7XG4gICAgICAgICAgICBzZXRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG5cbiAgICAgICAgICAgIC8vIHNldCBpZCBvZiBsYXN0IG1lc3NhZ2U6XG4gICAgICAgICAgICBzZXRNZXNzYWdlcyhtZXNzYWdlcyA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgIGxhc3RNZXNzYWdlLmlkID0gdmFsdWUubWVzc2FnZUlkO1xuICAgICAgICAgICAgICByZXR1cm4gWy4uLm1lc3NhZ2VzLnNsaWNlKDAsIG1lc3NhZ2VzLmxlbmd0aCAtIDEpLCBsYXN0TWVzc2FnZV07XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICBzZXRFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc2V0RXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIHNldFN0YXR1cygnYXdhaXRpbmdfbWVzc2FnZScpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXMsXG4gICAgdGhyZWFkSWQsXG4gICAgaW5wdXQsXG4gICAgc2V0SW5wdXQsXG4gICAgaGFuZGxlSW5wdXRDaGFuZ2UsXG4gICAgc3VibWl0TWVzc2FnZSxcbiAgICBzdGF0dXMsXG4gICAgZXJyb3IsXG4gIH07XG59XG4iXSwibmFtZXMiOlsidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJ1c2VJZCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU1dSIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsInBhcnNlIiwidmFsdWUiLCJFcnJvciIsInR5cGUiLCJmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0IiwiZnVuY3Rpb25fY2FsbCIsImFyZ3VtZW50cyIsImRhdGFTdHJlYW1QYXJ0IiwiQXJyYXkiLCJpc0FycmF5IiwiZXJyb3JTdHJlYW1QYXJ0IiwiYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQiLCJpZCIsInJvbGUiLCJjb250ZW50IiwiZXZlcnkiLCJpdGVtIiwidGV4dCIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsIk5FV0xJTkUiLCJjaGFyQ29kZUF0IiwiY29uY2F0Q2h1bmtzIiwiY2h1bmtzIiwidG90YWxMZW5ndGgiLCJjb25jYXRlbmF0ZWRDaHVua3MiLCJVaW50OEFycmF5Iiwib2Zmc2V0IiwiY2h1bmsiLCJzZXQiLCJsZW5ndGgiLCJyZWFkRGF0YVN0cmVhbSIsInJlYWRlciIsImlzQWJvcnRlZCIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsInJlYWQiLCJwdXNoIiwiZGVjb2RlIiwic3RyZWFtIiwic3BsaXQiLCJmaWx0ZXIiLCJzdHJlYW1QYXJ0IiwiY2FuY2VsIiwiY3VzdG9tQWxwaGFiZXQiLCJuYW5vaWQiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJjb21wbGV4IiwiZGVjb2RlZCIsIkJvb2xlYW4iLCJDT01QTEVYX0hFQURFUiIsInBhcnNlQ29tcGxleFJlc3BvbnNlIiwiYWJvcnRDb250cm9sbGVyUmVmIiwidXBkYXRlIiwib25GaW5pc2giLCJnZW5lcmF0ZUlkIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiY3JlYXRlZEF0IiwicHJlZml4TWFwIiwiZGF0YSIsImN1cnJlbnQiLCJmdW5jdGlvbkNhbGxNZXNzYWdlIiwidG9vbENhbGxNZXNzYWdlIiwicmVzcG9uc2VNZXNzYWdlIiwibWVyZ2VkIiwibWVzc2FnZXMiLCJjYWxsQ2hhdEFwaSIsImFwaSIsImJvZHkiLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJhYm9ydENvbnRyb2xsZXIiLCJhcHBlbmRNZXNzYWdlIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiX2EiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiY2F0Y2giLCJlcnIiLCJvayIsImdldFJlYWRlciIsImlzQ29tcGxleE1vZGUiLCJnZXQiLCJzdHJlYW1lZFJlc3BvbnNlIiwicmVwbHlJZCIsImRvbmUiLCJzdGFydHNXaXRoIiwicGFyc2VkRnVuY3Rpb25DYWxsIiwicGFyc2VkVG9vbENhbGxzIiwicHJvY2Vzc0NoYXRTdHJlYW0iLCJnZXRTdHJlYW1lZFJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIiwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwiLCJ1cGRhdGVDaGF0UmVxdWVzdCIsImdldEN1cnJlbnRNZXNzYWdlcyIsIm1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UiLCJoYXNGb2xsb3dpbmdSZXNwb25zZSIsIm1lc3NhZ2UiLCJmdW5jdGlvbkNhbGwiLCJjb25zb2xlIiwid2FybiIsImZ1bmN0aW9uQ2FsbFJlc3BvbnNlIiwidG9vbENhbGxzIiwidG9vbENhbGwiLCJ0b29sQ2FsbFJlc3BvbnNlIiwiZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzIiwic3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UiLCJjaGF0UmVxdWVzdCIsIm11dGF0ZSIsIm11dGF0ZVN0cmVhbURhdGEiLCJleGlzdGluZ0RhdGEiLCJleHRyYU1ldGFkYXRhUmVmIiwibWVzc2FnZXNSZWYiLCJzZW5kRXh0cmFNZXNzYWdlRmllbGRzIiwiX2IiLCJwcmV2aW91c01lc3NhZ2VzIiwiY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQiLCJ0b29sX2NhbGxfaWQiLCJyZWFkUm93IiwicHJvbWlzZSIsInVpIiwibmV4dCIsImUiLCJvcHRpb25zIiwiZnVuY3Rpb25zIiwidG9vbHMiLCJ0b29sX2Nob2ljZSIsInVzZUNoYXQiLCJpbml0aWFsTWVzc2FnZXMiLCJpbml0aWFsSW5wdXQiLCJvbkVycm9yIiwiaG9va0lkIiwiaWRLZXkiLCJjaGF0S2V5IiwiaW5pdGlhbE1lc3NhZ2VzRmFsbGJhY2siLCJmYWxsYmFja0RhdGEiLCJpc0xvYWRpbmciLCJtdXRhdGVMb2FkaW5nIiwic3RyZWFtRGF0YSIsImVycm9yIiwic2V0RXJyb3IiLCJ0cmlnZ2VyUmVxdWVzdCIsIkFib3J0Q29udHJvbGxlciIsImNoYXRSZXF1ZXN0UGFyYW0iLCJhcHBlbmQiLCJjb25jYXQiLCJyZWxvYWQiLCJsYXN0TWVzc2FnZSIsInN0b3AiLCJhYm9ydCIsInNldE1lc3NhZ2VzIiwiaW5wdXQiLCJzZXRJbnB1dCIsImhhbmRsZVN1Ym1pdCIsIm1ldGFkYXRhIiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVJbnB1dENoYW5nZSIsInRhcmdldCIsImNhbGxDb21wbGV0aW9uQXBpIiwicHJvbXB0Iiwic2V0Q29tcGxldGlvbiIsInNldExvYWRpbmciLCJzZXRBYm9ydENvbnRyb2xsZXIiLCJvbkRhdGEiLCJyZXMiLCJyZXN1bHQiLCJ1c2VDb21wbGV0aW9uIiwiaW5pdGlhbENvbXBsZXRpb24iLCJjb21wbGV0aW9uSWQiLCJjb21wbGV0aW9uIiwiY29tcGxldGUiLCJleHBlcmltZW50YWxfdXNlQXNzaXN0YW50IiwidGhyZWFkSWRQYXJhbSIsInNldFRocmVhZElkIiwic3RhdHVzIiwic2V0U3RhdHVzIiwiZXZlbnQiLCJzdWJtaXRNZXNzYWdlIiwicmVxdWVzdE9wdGlvbnMiLCJjYWxsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ })

};
;